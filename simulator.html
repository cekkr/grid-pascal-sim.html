<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Grid Propagation Simulator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/lib/codemirror.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/theme/darcula.min.css">
    <style>
        :root {
            --bg-color: #1a1a1d;
            --panel-bg: #2c2c34;
            --text-color: #f0f0f0;
            --primary-color: #4c82f7;
            --border-color: #444;
            --input-bg: #3a3a44;
            --error-color: #e57373;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        #main-container {
            display: flex;
            flex-grow: 1;
            min-width: 0;
        }

        #controls {
            width: 380px;
            min-width: 260px;
            max-width: 720px;
            padding: 15px;
            background-color: var(--panel-bg);
            border-right: 2px solid var(--border-color);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #sidebarResizer {
            flex: 0 0 6px;
            width: 6px;
            cursor: col-resize;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0));
            border-left: 1px solid rgba(255, 255, 255, 0.08);
            border-right: 1px solid rgba(0, 0, 0, 0.35);
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: var(--bg-color);
            cursor: grab;
            min-width: 0;
        }
        #canvas-container:active { cursor: grabbing; }

        #gridCanvas { 
            display: block; 
            width: 100%;
            height: 100%;        
        }
        
        .control-group {
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 5px;
        }

        .control-group h3 {
            margin-top: 0;
            font-size: 1em;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        
        label { display: block; margin-bottom: 5px; font-size: 0.9em; }

        input, select, textarea, button {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        
        textarea { font-family: "Courier New", monospace; resize: vertical; }

        .editor-container { position: relative; }
        .CodeMirror {
            height: auto;
            background-color: var(--input-bg);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 0.9em;
        }
        .CodeMirror-scroll {
            padding-bottom: 8px;
        }
        .editor-error {
            box-shadow: 0 0 0 1px var(--error-color);
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #6a9eff; }

        .button-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .storage-buttons { display: flex; gap: 10px; }
        #deleteProjectBtn { background-color: #c94c4c; }
        #deleteProjectBtn:hover { background-color: #e06c6c; }

        body.resizing-horizontal,
        body.resizing-vertical {
            user-select: none;
        }
        body.resizing-horizontal { cursor: col-resize; }
        body.resizing-vertical { cursor: row-resize; }

        #codeEditorPanel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #codeEditorPanel.collapsed {
            gap: 0;
        }
        .editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .editor-header h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        .editor-toggle {
            width: auto;
            padding: 6px 12px;
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }
        .editor-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .editor-tabs {
            display: flex;
            gap: 6px;
        }
        .editor-tab {
            width: auto;
            flex: 1;
            padding: 6px 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-color);
            font-size: 0.9em;
            transition: background-color 0.15s, border-color 0.15s;
        }
        .editor-tab.active {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        .editor-tab:not(.active):hover {
            background-color: rgba(255, 255, 255, 0.12);
        }
        .editor-content {
            position: relative;
            height: 240px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--input-bg);
            overflow: hidden;
        }
        #codeEditorPanel.collapsed .editor-tabs,
        #codeEditorPanel.collapsed .editor-content,
        #codeEditorPanel.collapsed .editor-resizer {
            display: none;
        }
        .editor-pane {
            position: absolute;
            inset: 0;
            display: none;
            padding: 8px;
            box-sizing: border-box;
            flex-direction: column;
            gap: 6px;
        }
        .editor-pane.active {
            display: flex;
        }
        .editor-pane label {
            margin-bottom: 0;
            font-size: 0.85em;
            opacity: 0.85;
        }
        .editor-pane .CodeMirror {
            flex: 1;
            height: 100%;
        }
        .editor-resizer {
            height: 10px;
            cursor: row-resize;
            border: 1px solid rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.02));
        }
        .editor-resizer:hover {
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.28), rgba(255, 255, 255, 0.06));
        }

        #inspector-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(44, 44, 52, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            color: var(--text-color);
            font-size: 0.9em;
            display: none; /* Hidden by default */
            width: 250px;
            pointer-events: auto;
        }
        #inspector-panel .close-btn {
            position: absolute;
            top: 5px; right: 8px;
            cursor: pointer; font-weight: bold;
            pointer-events: auto;
        }
        .inspector-node-links {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-left: 4px;
            min-width: 0;
        }
        .inspector-node-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: rgba(255, 255, 255, 0.08);
            cursor: pointer;
            color: inherit;
            font-size: 0.85em;
            pointer-events: auto;
            user-select: none;
        }
        .inspector-node-link:hover,
        .inspector-node-link:focus {
            background-color: rgba(76, 130, 247, 0.2);
            border-color: var(--primary-color);
            outline: none;
        }

        #customGradientInputs {
            display: none;
            gap: 10px;
        }
        #customGradientInputs input {
            width: calc(50% - 5px);
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="controls">
            <h2>Propagation Controls</h2>
            
            <div class="control-group">
                <h3>Simulation Core</h3>
                <label for="generations">Generations</label>
                <input type="number" id="generations" value="100" min="1" max="10000">
                <label for="reunification">Reunification Logic</label>
                <select id="reunification">
                    <option value="sum" selected>Sum</option>
                    <option value="average">Average</option>
                    <option value="max">Maximum</option>
                </select>
            </div>

            <div class="control-group">
                <h3>Propagation Rules</h3>
                <label for="moves">Move Vectors [dx, dy]</label>
                <textarea id="moves">[[1, -1], [1, 1]]</textarea>
            </div>

            <div class="control-group" id="codeEditorPanel">
                <div class="editor-header">
                    <h3>Logic Editors</h3>
                    <button type="button" class="editor-toggle" id="editorToggleBtn" aria-expanded="true">Hide Editors</button>
                </div>
                <div class="editor-tabs" id="codeEditorTabs">
                    <button type="button" class="editor-tab active" data-target-editor="propagationLogic">Propagation</button>
                    <button type="button" class="editor-tab" data-target-editor="colorLogic">Color</button>
                    <button type="button" class="editor-tab" data-target-editor="hdrLogic">HDR</button>
                </div>
                <div class="editor-content" id="codeEditorContent">
                    <div class="editor-pane active" data-editor-pane="propagationLogic">
                        <label for="propagationLogic">Propagation Function(parentValue, index, move)</label>
                        <textarea id="propagationLogic">// 'Left' branch (index 0) gains value, 'right' loses.
if (index === 0) {
    return parentValue + 0.2;
} else {
    return parentValue - 0.3;
}</textarea>
                    </div>
                    <div class="editor-pane" data-editor-pane="colorLogic">
                        <label for="colorLogic">Color Logic Function(value, stats, range, context)</label>
                        <textarea id="colorLogic">const clamp01 = (num) => Math.min(Math.max(num, 0), 1);
const safeMax = range.max > 0 ? range.max : 1;
const safeMin = range.min < 0 ? range.min : -1;
const viewScale = (context && typeof context.scale === 'number') ? context.scale : 1;
const intensity = viewScale < 1 ? Math.min(1.6, Math.pow(1 / Math.max(viewScale, 0.0001), 0.3)) : 1;
const applyHDR = (context && typeof context.applyHDR === 'function')
    ? context.applyHDR
    : ((input) => clamp01(input.ratio));

const sampleStops = (stops, ratio) => {
    const clamped = clamp01(ratio);
    if (clamped <= stops[0].stop) return stops[0].rgb.slice();
    for (let i = 0; i < stops.length - 1; i++) {
        const left = stops[i];
        const right = stops[i + 1];
        if (clamped >= left.stop && clamped <= right.stop) {
            const span = right.stop - left.stop || 1;
            const t = (clamped - left.stop) / span;
            return left.rgb.map((channel, idx) =>
                Math.round(channel + (right.rgb[idx] - channel) * t)
            );
        }
    }
    return stops[stops.length - 1].rgb.slice();
};

const enhanceRatio = (ratio) => clamp01(Math.pow(clamp01(ratio), 1 / intensity));
const toCss = (rgb) => `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;

const positiveStops = [
    { stop: 0, rgb: [255, 250, 165] },
    { stop: 0.33, rgb: [253, 197, 110] },
    { stop: 0.66, rgb: [244, 109, 67] },
    { stop: 1, rgb: [180, 23, 44] },
];
const negativeStops = [
    { stop: 0, rgb: [194, 230, 255] },
    { stop: 0.33, rgb: [123, 190, 222] },
    { stop: 0.66, rgb: [50, 136, 189] },
    { stop: 1, rgb: [3, 52, 118] },
];

if (value >= 0) {
    const hdrRatio = applyHDR({ ratio: value / safeMax, value, stats, range, polarity: 'positive', scale: viewScale });
    const ratio = enhanceRatio(hdrRatio);
    return toCss(sampleStops(positiveStops, ratio));
}
const hdrRatio = applyHDR({ ratio: Math.abs(value / safeMin), value, stats, range, polarity: 'negative', scale: viewScale });
const ratio = enhanceRatio(hdrRatio);
return toCss(sampleStops(negativeStops, ratio));</textarea>
                    </div>
                    <div class="editor-pane" data-editor-pane="hdrLogic">
                        <label for="hdrLogic">HDR Mapping Function(input, context)</label>
                        <textarea id="hdrLogic">const clamp01 = (num) => Math.min(Math.max(num, 0), 1);
const { ratio, scale } = input;
const base = clamp01(ratio);
const shoulder = Math.log1p(base * 8) / Math.log1p(8);
const gamma = Math.pow(base, 0.025);
const mix = 0.9;
let result = (1 - mix) * shoulder + mix * gamma;
if (scale && scale < 1) {
    result *= Math.min(1.45, Math.pow(1 / Math.max(scale, 0.0001), 0.12));
}
return clamp01(result);</textarea>
                    </div>
                </div>
                <div class="editor-resizer" id="editorResizer" title="Drag to resize editors"></div>
            </div>

            <div class="control-group">
                <h3>Visualization</h3>
                <label for="gradientMode">Gradient Scale</label>
                <select id="gradientMode">
                    <option value="symmetric" selected>Symmetric ±max</option>
                    <option value="positive">0 → max</option>
                    <option value="negative">min → 0</option>
                    <option value="custom">Custom range</option>
                </select>
                <div id="customGradientInputs">
                    <input type="number" id="gradientMin" placeholder="Min (e.g., -1)" step="0.1" value="-1">
                    <input type="number" id="gradientMax" placeholder="Max (e.g., 1)" step="0.1" value="1">
                </div>
            </div>
            
            <div class="control-group">
                <h3>Presets</h3>
                <div class="button-grid">
                    <button id="presetPascal">Pascal</button>
                    <button id="presetDivergent">Divergent</button>
                    <button id="presetBackwards">Echo</button>
                    <button id="presetDecay">Decay</button>
                    <button id="presetSierpinski">Sierpinski</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Projects (Local Storage)</h3>
                <input type="text" id="projectName" placeholder="My Divergent Model">
                <div class="storage-buttons">
                    <button id="saveProjectBtn">Save</button>
                    <button id="deleteProjectBtn">Delete</button>
                </div>
                <select id="loadProjectSelect"></select>
            </div>
        </div>
        <div id="sidebarResizer" role="separator" aria-orientation="vertical" aria-label="Resize controls panel"></div>
        <div id="canvas-container">
            <canvas id="gridCanvas"></canvas>
            <div id="inspector-panel">
                <span class="close-btn" id="inspector-close-btn">&times;</span>
                <h4>Node Inspector</h4>
                <p><strong>Coords:</strong> <span id="inspector-coords"></span></p>
                <p><strong>Value:</strong> <span id="inspector-value"></span></p>
                <p><strong>Generation:</strong> <span id="inspector-gen"></span></p>
                <p><strong>Parents:</strong> <span id="inspector-parents" class="inspector-node-links"></span></p>
                <p><strong>Children:</strong> <span id="inspector-children" class="inspector-node-links"></span></p>
            </div>
        </div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/mode/javascript/javascript.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/addon/edit/closebrackets.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/addon/selection/active-line.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const inspectorPanel = document.getElementById('inspector-panel');
    const inspectorFields = {
        coords: document.getElementById('inspector-coords'),
        value: document.getElementById('inspector-value'),
        gen: document.getElementById('inspector-gen'),
        parents: document.getElementById('inspector-parents'),
        children: document.getElementById('inspector-children'),
    };
    const controls = {
        generations: document.getElementById('generations'),
        reunification: document.getElementById('reunification'),
        moves: document.getElementById('moves'),
        propagationLogic: document.getElementById('propagationLogic'),
        projectName: document.getElementById('projectName'),
        saveProjectBtn: document.getElementById('saveProjectBtn'),
        deleteProjectBtn: document.getElementById('deleteProjectBtn'),
        loadProjectSelect: document.getElementById('loadProjectSelect'),
        presetPascal: document.getElementById('presetPascal'),
        presetDivergent: document.getElementById('presetDivergent'),
        presetBackwards: document.getElementById('presetBackwards'),
        presetDecay: document.getElementById('presetDecay'),
        presetSierpinski: document.getElementById('presetSierpinski'),
        inspectorCloseBtn: document.getElementById('inspector-close-btn'),
        gradientMode: document.getElementById('gradientMode'),
        gradientMin: document.getElementById('gradientMin'),
        gradientMax: document.getElementById('gradientMax'),
        colorLogic: document.getElementById('colorLogic'),
        hdrLogic: document.getElementById('hdrLogic'),
    };
    const controlsPanel = document.getElementById('controls');
    const editorPanel = document.getElementById('codeEditorPanel');
    const editorTabs = Array.from(document.querySelectorAll('.editor-tab'));
    const editorPanes = Array.from(document.querySelectorAll('.editor-pane'));
    const editorContent = document.getElementById('codeEditorContent');
    const editorToggleBtn = document.getElementById('editorToggleBtn');
    const editorResizer = document.getElementById('editorResizer');
    const sidebarResizer = document.getElementById('sidebarResizer');

    const STORAGE_KEYS = {
        editorHeight: 'gridSimEditorHeight',
        sidebarWidth: 'gridSimSidebarWidth',
        editorCollapsed: 'gridSimEditorCollapsed',
    };
    const MIN_EDITOR_HEIGHT = 160;
    const MAX_EDITOR_HEIGHT = 640;
    const MIN_SIDEBAR_WIDTH = 260;
    const MAX_SIDEBAR_WIDTH = 720;

    const clampNumber = (value, min, max) => Math.min(Math.max(value, min), max);

    let activeEditorId = 'propagationLogic';
    let editorHeight = 240;
    let isEditorCollapsed = false;

    if (editorContent) {
        const storedHeight = parseInt(localStorage.getItem(STORAGE_KEYS.editorHeight), 10);
        if (Number.isFinite(storedHeight)) {
            editorHeight = clampNumber(storedHeight, MIN_EDITOR_HEIGHT, MAX_EDITOR_HEIGHT);
        } else {
            editorHeight = clampNumber(editorContent.offsetHeight || editorHeight, MIN_EDITOR_HEIGHT, MAX_EDITOR_HEIGHT);
        }
        editorContent.style.height = `${editorHeight}px`;
    }

    if (editorPanel) {
        isEditorCollapsed = localStorage.getItem(STORAGE_KEYS.editorCollapsed) === 'true';
        if (isEditorCollapsed) {
            editorPanel.classList.add('collapsed');
            if (editorToggleBtn) {
                editorToggleBtn.textContent = 'Show Editors';
                editorToggleBtn.setAttribute('aria-expanded', 'false');
            }
        } else if (editorToggleBtn) {
            editorToggleBtn.setAttribute('aria-expanded', 'true');
        }
    }

    if (controlsPanel) {
        const storedWidth = parseInt(localStorage.getItem(STORAGE_KEYS.sidebarWidth), 10);
        if (Number.isFinite(storedWidth)) {
            controlsPanel.style.width = `${clampNumber(storedWidth, MIN_SIDEBAR_WIDTH, MAX_SIDEBAR_WIDTH)}px`;
        }
    }

    const customGradientInputs = document.getElementById('customGradientInputs');
    const codeEditors = {};
    const defaultColorLogicSource = controls.colorLogic.value;
    const defaultPropagationSource = controls.propagationLogic.value;
    const defaultHdrLogicSource = controls.hdrLogic.value;

    function refreshEditorAfterLayout(editorId) {
        const instance = codeEditors[editorId];
        if (!instance) return;
        requestAnimationFrame(() => instance.refresh());
    }

    function ensureEditorExpanded() {
        if (!editorPanel || !editorPanel.classList.contains('collapsed')) return;
        editorPanel.classList.remove('collapsed');
        isEditorCollapsed = false;
        if (editorToggleBtn) {
            editorToggleBtn.textContent = 'Hide Editors';
            editorToggleBtn.setAttribute('aria-expanded', 'true');
        }
        localStorage.setItem(STORAGE_KEYS.editorCollapsed, 'false');
        if (editorContent) editorContent.style.height = `${editorHeight}px`;
        refreshEditorAfterLayout(activeEditorId);
    }

    function setActiveEditor(editorId) {
        if (!editorId) editorId = activeEditorId;
        activeEditorId = editorId;
        editorTabs.forEach(tab => {
            const isActive = tab.dataset.targetEditor === activeEditorId;
            tab.classList.toggle('active', isActive);
            tab.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
        editorPanes.forEach(pane => {
            const isActive = pane.dataset.editorPane === activeEditorId;
            pane.classList.toggle('active', isActive);
        });
        if (!isEditorCollapsed) refreshEditorAfterLayout(activeEditorId);
    }

    editorTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            if (!tab.dataset.targetEditor) return;
            ensureEditorExpanded();
            setActiveEditor(tab.dataset.targetEditor);
        });
    });

    if (editorToggleBtn && editorPanel) {
        editorToggleBtn.addEventListener('click', () => {
            const willCollapse = !editorPanel.classList.contains('collapsed');
            editorPanel.classList.toggle('collapsed', willCollapse);
            isEditorCollapsed = willCollapse;
            if (willCollapse) {
                editorToggleBtn.textContent = 'Show Editors';
                editorToggleBtn.setAttribute('aria-expanded', 'false');
            } else {
                editorToggleBtn.textContent = 'Hide Editors';
                editorToggleBtn.setAttribute('aria-expanded', 'true');
                if (editorContent) editorContent.style.height = `${editorHeight}px`;
                refreshEditorAfterLayout(activeEditorId);
            }
            localStorage.setItem(STORAGE_KEYS.editorCollapsed, willCollapse ? 'true' : 'false');
        });
    }

    if (editorResizer && editorContent) {
        let resizingEditors = false;
        let startY = 0;
        let startHeight = editorHeight;

        editorResizer.addEventListener('mousedown', event => {
            if (isEditorCollapsed) return;
            event.preventDefault();
            resizingEditors = true;
            startY = event.clientY;
            startHeight = editorContent.offsetHeight || editorHeight;
            document.body.classList.add('resizing-vertical');
        });

        window.addEventListener('mousemove', event => {
            if (!resizingEditors) return;
            const delta = event.clientY - startY;
            editorHeight = clampNumber(startHeight + delta, MIN_EDITOR_HEIGHT, MAX_EDITOR_HEIGHT);
            editorContent.style.height = `${editorHeight}px`;
            refreshEditorAfterLayout(activeEditorId);
        });

        window.addEventListener('mouseup', () => {
            if (!resizingEditors) return;
            resizingEditors = false;
            document.body.classList.remove('resizing-vertical');
            localStorage.setItem(STORAGE_KEYS.editorHeight, Math.round(editorHeight));
            refreshEditorAfterLayout(activeEditorId);
        });
    }

    if (sidebarResizer && controlsPanel) {
        let resizingSidebar = false;
        let startX = 0;
        let startWidth = controlsPanel.offsetWidth;

        sidebarResizer.addEventListener('mousedown', event => {
            event.preventDefault();
            resizingSidebar = true;
            startX = event.clientX;
            startWidth = controlsPanel.offsetWidth;
            document.body.classList.add('resizing-horizontal');
        });

        window.addEventListener('mousemove', event => {
            if (!resizingSidebar) return;
            const delta = event.clientX - startX;
            const nextWidth = clampNumber(startWidth + delta, MIN_SIDEBAR_WIDTH, MAX_SIDEBAR_WIDTH);
            controlsPanel.style.width = `${nextWidth}px`;
        });

        window.addEventListener('mouseup', () => {
            if (!resizingSidebar) return;
            resizingSidebar = false;
            document.body.classList.remove('resizing-horizontal');
            const storedWidth = clampNumber(Math.round(controlsPanel.offsetWidth), MIN_SIDEBAR_WIDTH, MAX_SIDEBAR_WIDTH);
            localStorage.setItem(STORAGE_KEYS.sidebarWidth, storedWidth);
            drawGrid();
        });
    }

    if (editorTabs.length) {
        setActiveEditor(activeEditorId);
    }

    const positiveColorStops = [
        { stop: 0, rgb: [255, 250, 165] },
        { stop: 0.33, rgb: [253, 197, 110] },
        { stop: 0.66, rgb: [244, 109, 67] },
        { stop: 1, rgb: [180, 23, 44] },
    ];
    const negativeColorStops = [
        { stop: 0, rgb: [194, 230, 255] },
        { stop: 0.33, rgb: [123, 190, 222] },
        { stop: 0.66, rgb: [50, 136, 189] },
        { stop: 1, rgb: [3, 52, 118] },
    ];

    const createStatsTracker = () => ({ min: Infinity, max: -Infinity, count: 0 });
    const resetStatsTracker = (tracker) => {
        tracker.min = Infinity;
        tracker.max = -Infinity;
        tracker.count = 0;
        return tracker;
    };
    const trackStatsValue = (tracker, value) => {
        if (!tracker || !Number.isFinite(value)) return;
        tracker.min = Math.min(tracker.min, value);
        tracker.max = Math.max(tracker.max, value);
        tracker.count += 1;
    };

    const clamp01 = (value) => Math.min(Math.max(value, 0), 1);
    const sampleColorStops = (stops, ratio) => {
        if (!stops.length) return [255, 255, 255];
        const clamped = clamp01(ratio);
        if (clamped <= stops[0].stop) return stops[0].rgb.slice();
        for (let i = 0; i < stops.length - 1; i++) {
            const left = stops[i];
            const right = stops[i + 1];
            if (clamped >= left.stop && clamped <= right.stop) {
                const span = right.stop - left.stop || 1;
                const t = (clamped - left.stop) / span;
                return left.rgb.map((channel, idx) =>
                    Math.round(channel + (right.rgb[idx] - channel) * t)
                );
            }
        }
        return stops[stops.length - 1].rgb.slice();
    };
    const accentuateRatio = (ratio, intensity) => {
        const safeIntensity = Math.max(intensity, 1);
        return clamp01(Math.pow(clamp01(ratio), 1 / safeIntensity));
    };
    const rgbArrayToCss = (rgb) => `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;

    const clampRatio = (value) => Math.min(Math.max(value, 0), 1);

    const defaultHdrFunction = (input, context = {}) => {
        if (!input) return 0;
        const scale = (context && typeof context.scale === 'number' && Number.isFinite(context.scale))
            ? context.scale
            : 1;
        const base = clamp01(input.ratio ?? 0);
        const shoulder = Math.log1p(base * 8) / Math.log1p(8);
        const gamma = Math.pow(base, 0.75);
        const mix = 0.35;
        let result = (1 - mix) * shoulder + mix * gamma;
        if (scale < 1) {
            result *= Math.min(1.45, Math.pow(1 / Math.max(scale, 0.0001), 0.12));
        }
        return clampRatio(result);
    };

    const defaultColorFunction = (value, stats, range, context = {}) => {
        const safeMax = range.max > 0 ? range.max : 1;
        const safeMin = range.min < 0 ? range.min : -1;
        const scale = (context && typeof context.scale === 'number' && Number.isFinite(context.scale))
            ? context.scale
            : 1;
        const intensity = scale < 1
            ? Math.min(1.6, Math.pow(1 / Math.max(scale, 0.0001), 0.3))
            : 1;

        const applyHDR = (context && typeof context.applyHDR === 'function')
            ? context.applyHDR
            : (input) => defaultHdrFunction(input, { scale });

        if (value >= 0) {
            const hdrRatio = clampRatio(applyHDR({ ratio: value / safeMax, value, stats, range, polarity: 'positive', scale }));
            const ratio = accentuateRatio(hdrRatio, intensity);
            return rgbArrayToCss(sampleColorStops(positiveColorStops, ratio));
        }
        const hdrRatio = clampRatio(applyHDR({ ratio: Math.abs(value / safeMin), value, stats, range, polarity: 'negative', scale }));
        const ratio = accentuateRatio(hdrRatio, intensity);
        return rgbArrayToCss(sampleColorStops(negativeColorStops, ratio));
    };
    let config = {};
    let grid = new Map();
    let selectedNodeKey = null;
    let view = { scale: 25, offsetX: 0, offsetY: 50, isDragging: false, lastX: 0, lastY: 0 };

    const MIN_PIXEL_NODE_RADIUS = 3;
    const MIN_PIXEL_EDGE_WIDTH = 0.6;
    const MIN_PIXEL_SELECTION_WIDTH = 1.8;
    const EDGE_RENDER_SCALE_THRESHOLD = 0.9;
    const AGGREGATION_SCALE_THRESHOLD = 6;
    const AGGREGATION_BUCKET_PIXELS = 8;
    const VIEW_CULL_PADDING = 1.5;

    function getNodeRadius() {
        return Math.max(0.2, MIN_PIXEL_NODE_RADIUS / Math.max(view.scale, 0.0001));
    }

    function getEdgeWidth() {
        return Math.max(0.02, MIN_PIXEL_EDGE_WIDTH / Math.max(view.scale, 0.0001));
    }

    function getSelectionWidth() {
        return Math.max(0.12, MIN_PIXEL_SELECTION_WIDTH / Math.max(view.scale, 0.0001));
    }

    function getCodeValue(id) {
        if (codeEditors[id]) return codeEditors[id].getValue();
        const field = document.getElementById(id);
        return field ? field.value || '' : '';
    }

    function setCodeValue(id, value) {
        const nextValue = value ?? '';
        if (codeEditors[id]) {
            if (codeEditors[id].getValue() !== nextValue) codeEditors[id].setValue(nextValue);
            return;
        }
        const field = document.getElementById(id);
        if (field) field.value = nextValue;
    }

    function setEditorError(id, hasError) {
        if (codeEditors[id]) {
            const wrapper = codeEditors[id].getWrapperElement();
            if (hasError) {
                wrapper.classList.add('editor-error');
                wrapper.style.borderColor = 'var(--error-color)';
            } else {
                wrapper.classList.remove('editor-error');
                wrapper.style.borderColor = '';
            }
        } else {
            const field = document.getElementById(id);
            if (field) field.style.borderColor = hasError ? 'var(--error-color)' : '';
        }
    }

    function toggleCustomGradientInputs() {
        customGradientInputs.style.display = controls.gradientMode.value === 'custom' ? 'flex' : 'none';
    }

    let runHandle = null;
    function scheduleRun() {
        if (runHandle) cancelAnimationFrame(runHandle);
        runHandle = requestAnimationFrame(() => {
            runHandle = null;
            run();
        });
    }

    if (window.CodeMirror) {
        const applySizing = (editor) => {
            if (!editor) return;
            editor.setSize(null, '100%');
        };

        codeEditors.propagationLogic = CodeMirror.fromTextArea(controls.propagationLogic, {
            mode: 'javascript',
            theme: 'darcula',
            lineNumbers: true,
            lineWrapping: true,
            autoCloseBrackets: true,
            styleActiveLine: true,
        });
        applySizing(codeEditors.propagationLogic);
        codeEditors.propagationLogic.on('change', scheduleRun);

        codeEditors.colorLogic = CodeMirror.fromTextArea(controls.colorLogic, {
            mode: 'javascript',
            theme: 'darcula',
            lineNumbers: true,
            lineWrapping: true,
            autoCloseBrackets: true,
            styleActiveLine: true,
        });
        applySizing(codeEditors.colorLogic);
        codeEditors.colorLogic.on('change', scheduleRun);

        codeEditors.hdrLogic = CodeMirror.fromTextArea(controls.hdrLogic, {
            mode: 'javascript',
            theme: 'darcula',
            lineNumbers: true,
            lineWrapping: true,
            autoCloseBrackets: true,
            styleActiveLine: true,
        });
        applySizing(codeEditors.hdrLogic);
        codeEditors.hdrLogic.on('change', scheduleRun);

        if (editorTabs.length) {
            setActiveEditor(activeEditorId);
        }
    } else {
        controls.propagationLogic.addEventListener('input', scheduleRun);
        controls.colorLogic.addEventListener('input', scheduleRun);
        controls.hdrLogic.addEventListener('input', scheduleRun);
    }

    function generateGrid() {
        grid.clear();
        selectedNodeKey = null;
        const startNodeKey = "0,0";
        grid.set(startNodeKey, { value: 1.0, gen: 0, parents: [], children: [] });
        let frontier = new Set([startNodeKey]);

        for (let i = 0; i < config.generations; i++) {
            const nextFrontier = new Set();
            const contributions = new Map();
            for (const nodeKey of frontier) {
                const node = grid.get(nodeKey);
                if (!node) continue;
                const [x, y] = nodeKey.split(',').map(Number);
                
                config.moves.forEach((move, index) => {
                    const valueToPass = config.propagate(node.value, index, move);
                    const childX = x + move[0];
                    const childY = y + move[1];
                    const childKey = `${childX},${childY}`;
                    if (!Array.isArray(node.children)) node.children = [];
                    if (!node.children.includes(childKey)) node.children.push(childKey);
                    if (!contributions.has(childKey)) contributions.set(childKey, []);
                    contributions.get(childKey).push({value: valueToPass, parentKey: nodeKey});
                });
            }
            for (const [childKey, incoming] of contributions.entries()) {
                const incomingValues = incoming.map(c => c.value);
                const parentKeys = Array.from(new Set(incoming.map(c => c.parentKey)));
                let finalValue = 0;
                switch (config.reunification) {
                    case 'sum': finalValue = incomingValues.reduce((a, b) => a + b, 0); break;
                    case 'average': finalValue = incomingValues.reduce((a, b) => a + b, 0) / incomingValues.length; break;
                    case 'max': finalValue = Math.max(...incomingValues); break;
                }
                if (grid.has(childKey)) {
                    const childNode = grid.get(childKey);
                    childNode.value += finalValue;
                    if (!Array.isArray(childNode.parents)) childNode.parents = [];
                    parentKeys.forEach(parentKey => {
                        if (!childNode.parents.includes(parentKey)) childNode.parents.push(parentKey);
                    });
                } else {
                    grid.set(childKey, { value: finalValue, gen: i + 1, parents: parentKeys, children: [] });
                }
                nextFrontier.add(childKey);
            }
            frontier = nextFrontier;
        }
    }

    function drawGrid() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(canvas.width / 2 + view.offsetX, canvas.height / 2 + view.offsetY);
        ctx.scale(view.scale, view.scale);

        const stats = computeGridStats();
        const nodeRadius = getNodeRadius();
        const selectionWidth = getSelectionWidth();
        const edgeWidth = getEdgeWidth();
        const safeScale = Math.max(view.scale, 0.0001);

        const hdrContext = { scale: view.scale };
        const applyHDR = (input) => {
            try {
                if (config.hdrFn) {
                    const result = config.hdrFn(input, hdrContext);
                    if (Number.isFinite(result)) return clampRatio(result);
                }
            } catch (error) {
                console.warn('HDR logic error', error);
            }
            return defaultHdrFunction(input, hdrContext);
        };
        const colorContext = { scale: view.scale, applyHDR, clusterSize: 1, visibleStats: null, gradientRange: null };

        const padding = nodeRadius + VIEW_CULL_PADDING;
        const halfWidth = canvas.width / 2;
        const halfHeight = canvas.height / 2;
        const viewport = {
            minX: (-halfWidth - view.offsetX) / safeScale - padding,
            maxX: (halfWidth - view.offsetX) / safeScale + padding,
            minY: (-halfHeight - view.offsetY) / safeScale - padding,
            maxY: (halfHeight - view.offsetY) / safeScale + padding,
        };

        const shouldAggregate = view.scale < AGGREGATION_SCALE_THRESHOLD;
        const renderEdges = !shouldAggregate && view.scale >= EDGE_RENDER_SCALE_THRESHOLD;
        const visibleNodes = new Map();
        const aggregatedBuckets = new Map();

        const valueStatsTracker = createStatsTracker();
        const renderStatsTracker = createStatsTracker();

        const bucketWorldSize = shouldAggregate
            ? Math.max(AGGREGATION_BUCKET_PIXELS / safeScale, nodeRadius * 2)
            : 0;

        for (const [key, node] of grid.entries()) {
            const [x, y] = key.split(',').map(Number);
            if (x < viewport.minX || x > viewport.maxX || y < viewport.minY || y > viewport.maxY) continue;

            trackStatsValue(valueStatsTracker, node.value);

            if (shouldAggregate) {
                const bucketX = Math.round(x / bucketWorldSize);
                const bucketY = Math.round(y / bucketWorldSize);
                const bucketKey = `${bucketX},${bucketY}`;
                let bucket = aggregatedBuckets.get(bucketKey);
                if (!bucket) {
                    bucket = { xSum: 0, ySum: 0, valueSum: 0, count: 0, maxValue: -Infinity, minValue: Infinity };
                    aggregatedBuckets.set(bucketKey, bucket);
                }
                bucket.xSum += x;
                bucket.ySum += y;
                bucket.valueSum += node.value;
                bucket.count += 1;
                bucket.maxValue = Math.max(bucket.maxValue, node.value);
                bucket.minValue = Math.min(bucket.minValue, node.value);
            } else {
                visibleNodes.set(key, { node, x, y });
                trackStatsValue(renderStatsTracker, node.value);
            }
        }

        if (renderEdges && visibleNodes.size) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
            ctx.lineWidth = edgeWidth;
            for (const [key, entry] of visibleNodes.entries()) {
                const { node, x: x1, y: y1 } = entry;
                for (const parentKey of node.parents) {
                    const parent = visibleNodes.get(parentKey);
                    if (!parent) continue;
                    ctx.beginPath();
                    ctx.moveTo(parent.x, parent.y);
                    ctx.lineTo(x1, y1);
                    ctx.stroke();
                }
            }
        }

        let visibleStatsForRange = renderStatsTracker.count ? renderStatsTracker : valueStatsTracker;
        let gradientRange = resolveGradientRange(stats, visibleStatsForRange, view);
        colorContext.visibleStats = visibleStatsForRange;
        colorContext.gradientRange = gradientRange;

        if (shouldAggregate) {
            resetStatsTracker(renderStatsTracker);
            for (const bucket of aggregatedBuckets.values()) {
                if (!bucket.count) continue;
                const averageValue = bucket.valueSum / bucket.count;
                const strongestAbs = Math.abs(bucket.maxValue) >= Math.abs(bucket.minValue) ? bucket.maxValue : bucket.minValue;
                const blend = Math.min(0.7, bucket.count / 12);
                const displayValue = averageValue * (1 - blend) + strongestAbs * blend;
                bucket.displayValue = displayValue;
                trackStatsValue(renderStatsTracker, displayValue);
            }
            visibleStatsForRange = renderStatsTracker.count ? renderStatsTracker : valueStatsTracker;
            gradientRange = resolveGradientRange(stats, visibleStatsForRange, view);
            colorContext.visibleStats = visibleStatsForRange;
            colorContext.gradientRange = gradientRange;

            for (const bucket of aggregatedBuckets.values()) {
                if (!bucket.count) continue;
                const avgX = bucket.xSum / bucket.count;
                const avgY = bucket.ySum / bucket.count;
                const sizeBoost = Math.min(3, Math.sqrt(bucket.count));
                const adjustedRadius = Math.max(nodeRadius, nodeRadius * sizeBoost);
                colorContext.clusterSize = bucket.count;
                const displayValue = bucket.displayValue ?? (bucket.valueSum / bucket.count);
                ctx.fillStyle = getNodeColor(displayValue, stats, gradientRange, colorContext);
                ctx.beginPath();
                ctx.arc(avgX, avgY, adjustedRadius, 0, 2 * Math.PI);
                ctx.fill();
            }

            if (selectedNodeKey && grid.has(selectedNodeKey)) {
                const [sx, sy] = selectedNodeKey.split(',').map(Number);
                if (sx >= viewport.minX && sx <= viewport.maxX && sy >= viewport.minY && sy <= viewport.maxY) {
                    const node = grid.get(selectedNodeKey);
                    colorContext.clusterSize = 1;
                    ctx.fillStyle = getNodeColor(node.value, stats, gradientRange, colorContext);
                    ctx.beginPath();
                    ctx.arc(sx, sy, Math.max(nodeRadius, nodeRadius * 1.25), 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = selectionWidth;
                    ctx.stroke();
                }
            }
        } else {
            colorContext.clusterSize = 1;
            for (const [key, entry] of visibleNodes.entries()) {
                const { node, x, y } = entry;
                ctx.fillStyle = getNodeColor(node.value, stats, gradientRange, colorContext);
                ctx.beginPath();
                ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
                ctx.fill();
                if (key === selectedNodeKey) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = selectionWidth;
                    ctx.stroke();
                }
            }
        }
        ctx.restore();
    }

    function computeGridStats() {
        let min = Infinity;
        let max = -Infinity;
        for (const node of grid.values()) {
            min = Math.min(min, node.value);
            max = Math.max(max, node.value);
        }
        if (!grid.size) {
            min = 0;
            max = 0;
        }
        return { min, max };
    }

    function resolveGradientRange(globalStats, viewStats, viewState) {
        const fallbackMin = (globalStats && Number.isFinite(globalStats.min)) ? globalStats.min : 0;
        const fallbackMax = (globalStats && Number.isFinite(globalStats.max)) ? globalStats.max : 0;
        const hasViewSamples = viewStats && Number.isFinite(viewStats.min) && Number.isFinite(viewStats.max) && viewStats.count > 0;

        let blend = 0;
        if (hasViewSamples) {
            const countFactor = clampNumber(viewStats.count / 40, 0, 1);
            const scaleFactor = (viewState && Number.isFinite(viewState.scale))
                ? clampNumber(Math.log10(viewState.scale + 1) / 1.6, 0, 1)
                : 0.2;
            blend = clampNumber(0.2 + countFactor * 0.6 + scaleFactor * 0.2, 0, 1);
        }

        const mixValue = (viewValue, fallbackValue) => {
            if (!hasViewSamples) return fallbackValue;
            return viewValue * blend + fallbackValue * (1 - blend);
        };

        const padRange = (minValue, maxValue) => {
            if (minValue === maxValue) {
                const padding = Math.max(Math.abs(minValue) * 0.25, 0.5);
                return { min: minValue - padding, max: maxValue + padding };
            }
            const span = maxValue - minValue;
            const padding = span * 0.08 || 0.5;
            return { min: minValue - padding, max: maxValue + padding };
        };

        switch (config.gradientMode) {
            case 'positive': {
                const viewMax = hasViewSamples ? Math.max(0, viewStats.max) : 0;
                const fallbackPositive = fallbackMax > 0 ? fallbackMax : 1;
                const resolvedMax = mixValue(Math.max(viewMax, 0), Math.max(fallbackPositive, 1));
                return padRange(0, resolvedMax);
            }
            case 'negative': {
                const viewMin = hasViewSamples ? Math.min(0, viewStats.min) : 0;
                const fallbackNegative = fallbackMin < 0 ? fallbackMin : -1;
                const resolvedMin = mixValue(Math.min(viewMin, 0), Math.min(fallbackNegative, -1));
                return padRange(resolvedMin, 0);
            }
            case 'custom': {
                if (!config.gradientCustom) return padRange(-1, 1);
                let { min, max } = config.gradientCustom;
                if (!Number.isFinite(min) || !Number.isFinite(max)) {
                    min = fallbackMin;
                    max = fallbackMax;
                }
                if (min === max) {
                    return padRange(min, max);
                }
                return { min, max };
            }
            case 'symmetric':
            default: {
                const globalAbs = Math.max(Math.abs(fallbackMin), Math.abs(fallbackMax), 1);
                const viewAbs = hasViewSamples
                    ? Math.max(Math.abs(viewStats.min), Math.abs(viewStats.max), 0)
                    : globalAbs;
                const resolvedAbs = mixValue(viewAbs, globalAbs);
                return padRange(-resolvedAbs, resolvedAbs);
            }
        }
    }

    function getNodeColor(value, stats, range, context) {
        try {
            const result = config.colorFn(value, stats, range, context);
            if (typeof result === 'string') return result;
        } catch (error) {
            console.warn('Color logic error', error);
        }
        return defaultColorFunction(value, stats, range, context);
    }
    
    function updateConfigFromUI() {
        controls.generations.style.borderColor = '';
        controls.moves.style.borderColor = '';
        controls.gradientMin.style.borderColor = '';
        controls.gradientMax.style.borderColor = '';
        setEditorError('propagationLogic', false);
        setEditorError('colorLogic', false);
        setEditorError('hdrLogic', false);

        const generations = parseInt(controls.generations.value, 10);
        if (!Number.isFinite(generations) || generations < 1) {
            controls.generations.style.borderColor = 'var(--error-color)';
            return false;
        }

        let moves;
        try {
            moves = JSON.parse(controls.moves.value);
        } catch (error) {
            controls.moves.style.borderColor = 'var(--error-color)';
            return false;
        }

        const propagationSource = getCodeValue('propagationLogic');
        let propagate;
        try {
            propagate = new Function('parentValue', 'index', 'move', `return (() => { ${propagationSource} })();`);
            // quick validation to surface syntax errors early
            propagate(1, 0, [0, 0]);
        } catch (error) {
            setEditorError('propagationLogic', true);
            return false;
        }

        const gradientMode = controls.gradientMode.value;
        let gradientCustom = null;
        if (gradientMode === 'custom') {
            const minVal = parseFloat(controls.gradientMin.value);
            const maxVal = parseFloat(controls.gradientMax.value);
            if (!Number.isFinite(minVal) || !Number.isFinite(maxVal) || minVal >= maxVal) {
                controls.gradientMin.style.borderColor = 'var(--error-color)';
                controls.gradientMax.style.borderColor = 'var(--error-color)';
                return false;
            }
            gradientCustom = { min: minVal, max: maxVal };
        }

        const colorLogicSource = getCodeValue('colorLogic');
        let colorFn;
        try {
            colorFn = new Function('value', 'stats', 'range', 'context', `return (() => { ${colorLogicSource} })();`);
            const hdrPreview = (input) => defaultHdrFunction(input, { scale: view.scale });
            colorFn(0, { min: 0, max: 0 }, { min: 0, max: 1 }, { scale: view.scale, applyHDR: hdrPreview });
        } catch (error) {
            setEditorError('colorLogic', true);
            return false;
        }

        const hdrLogicSource = getCodeValue('hdrLogic');
        let hdrFn;
        try {
            hdrFn = new Function('input', 'context', `return (() => { ${hdrLogicSource} })();`);
            hdrFn({ ratio: 0.5, value: 0.5, stats: { min: 0, max: 1 }, range: { min: -1, max: 1 }, polarity: 'positive', scale: view.scale }, { scale: view.scale });
        } catch (error) {
            setEditorError('hdrLogic', true);
            return false;
        }

        config = {
            generations,
            reunification: controls.reunification.value,
            moves,
            propagate,
            propagationSource,
            gradientMode,
            gradientCustom,
            colorFn,
            colorLogicSource,
            hdrFn,
            hdrLogicSource,
        };
        return true;
    }
    
    function updateUIFromConfig() {
        controls.generations.value = config.generations;
        controls.reunification.value = config.reunification;
        controls.moves.value = JSON.stringify(config.moves, null, 2);
        setCodeValue('propagationLogic', config.propagationSource || defaultPropagationSource);
        controls.gradientMode.value = config.gradientMode || 'symmetric';
        if (config.gradientMode === 'custom' && config.gradientCustom) {
            controls.gradientMin.value = config.gradientCustom.min;
            controls.gradientMax.value = config.gradientCustom.max;
        }
        setCodeValue('colorLogic', config.colorLogicSource || defaultColorLogicSource);
        setCodeValue('hdrLogic', config.hdrLogicSource || defaultHdrLogicSource);
        toggleCustomGradientInputs();
    }

    function run() {
        if (updateConfigFromUI()) {
            generateGrid();
            drawGrid();
            inspectorPanel.style.display = 'none';
        }
    }
    
    function findNodeAt(mouseX, mouseY) {
        const rect = canvas.getBoundingClientRect();
        const gridX = (mouseX - rect.left - (canvas.width / 2 + view.offsetX)) / view.scale;
        const gridY = (mouseY - rect.top - (canvas.height / 2 + view.offsetY)) / view.scale;
        const aggregationMultiplier = view.scale < AGGREGATION_SCALE_THRESHOLD
            ? Math.min(3, Math.max(1.5, AGGREGATION_SCALE_THRESHOLD / Math.max(view.scale, 0.1)))
            : 1;
        const hitRadius = Math.max(getNodeRadius() * aggregationMultiplier, 0.3);
        for (const [key, node] of grid.entries()) {
            const [nodeX, nodeY] = key.split(',').map(Number);
            if (Math.hypot(gridX - nodeX, gridY - nodeY) < hitRadius) return key;
        }
        return null;
    }

    function updateInspectorPanel(nodeKey) {
        if (!nodeKey || !grid.has(nodeKey)) {
            inspectorPanel.style.display = 'none';
            return;
        }
        const node = grid.get(nodeKey);
        if (inspectorFields.coords) inspectorFields.coords.textContent = `(${nodeKey})`;
        if (inspectorFields.value) inspectorFields.value.textContent = node.value.toFixed(4);
        if (inspectorFields.gen) inspectorFields.gen.textContent = node.gen;
        renderInspectorNodeLinks(inspectorFields.parents, Array.isArray(node.parents) ? node.parents : []);
        renderInspectorNodeLinks(inspectorFields.children, Array.isArray(node.children) ? node.children : []);
        inspectorPanel.style.display = 'block';
    }

    function renderInspectorNodeLinks(container, keys) {
        if (!container) return;
        container.innerHTML = '';
        const uniqueKeys = Array.from(new Set((keys || []).filter(Boolean)));
        if (!uniqueKeys.length) {
            container.textContent = 'None';
            return;
        }
        uniqueKeys.forEach(key => {
            const link = document.createElement('span');
            link.className = 'inspector-node-link';
            link.dataset.nodeKey = key;
            link.setAttribute('role', 'button');
            link.setAttribute('tabindex', '0');
            link.textContent = key;
            container.appendChild(link);
        });
    }

    function saveProject() {
        const name = controls.projectName.value.trim();
        if (!name) { alert('Please enter a project name.'); return; }
        if (!updateConfigFromUI()) { alert('Please resolve configuration errors before saving.'); return; }
        const projects = JSON.parse(localStorage.getItem('gridSimProjects') || '{}');
        projects[name] = {
            generations: config.generations,
            reunification: config.reunification,
            moves: config.moves,
            logic: config.propagationSource,
            gradientMode: config.gradientMode,
            gradientCustom: config.gradientCustom,
            colorLogic: config.colorLogicSource,
            hdrLogic: config.hdrLogicSource,
            version: 2,
        };
        localStorage.setItem('gridSimProjects', JSON.stringify(projects));
        updateProjectList();
    }

    function loadProject() {
        const name = controls.loadProjectSelect.value;
        if (!name) return;
        const projects = JSON.parse(localStorage.getItem('gridSimProjects') || '{}');
        if (projects[name]) {
            const proj = projects[name];
            controls.generations.value = proj.generations;
            controls.reunification.value = proj.reunification;
            controls.moves.value = JSON.stringify(proj.moves, null, 2);
            setCodeValue('propagationLogic', proj.logic || defaultPropagationSource);
            controls.gradientMode.value = proj.gradientMode || 'symmetric';
            if (controls.gradientMode.value === 'custom' && proj.gradientCustom) {
                controls.gradientMin.value = proj.gradientCustom.min;
                controls.gradientMax.value = proj.gradientCustom.max;
            }
            setCodeValue('colorLogic', proj.colorLogic || defaultColorLogicSource);
            setCodeValue('hdrLogic', proj.hdrLogic || defaultHdrLogicSource);
            controls.projectName.value = name;
            toggleCustomGradientInputs();
            scheduleRun();
        }
    }

    function deleteProject() {
        const name = controls.loadProjectSelect.value;
        if (!name || !confirm(`Delete project "${name}"?`)) return;
        const projects = JSON.parse(localStorage.getItem('gridSimProjects') || '{}');
        delete projects[name];
        localStorage.setItem('gridSimProjects', JSON.stringify(projects));
        controls.projectName.value = "";
        updateProjectList();
    }

    function updateProjectList() {
        const projects = JSON.parse(localStorage.getItem('gridSimProjects') || '{}');
        const currentSelection = controls.loadProjectSelect.value;
        controls.loadProjectSelect.innerHTML = '<option value="">-- Load Project --</option>';
        for (const name in projects) {
            const option = document.createElement('option');
            option.value = name; option.textContent = name;
            controls.loadProjectSelect.appendChild(option);
        }
        controls.loadProjectSelect.value = currentSelection;
    }
    
    const presets = {
        pascal: {
            moves: `[[1, -1], [1, 1]]`,
            logic: `return parentValue;`,
            gradientMode: 'symmetric',
            colorLogic: defaultColorLogicSource,
            hdrLogic: defaultHdrLogicSource,
        },
        divergent: {
            moves: `[[1, -1], [1, 1]]`,
            logic: `if (index === 0) return parentValue + 0.2;\nelse return parentValue - 0.3;`,
            gradientMode: 'symmetric',
            colorLogic: defaultColorLogicSource,
            hdrLogic: defaultHdrLogicSource,
        },
        backwards: {
            moves: `[[1, -1], [1, 1], [-2, 0]]`,
            logic: `if(index === 2) return parentValue * 0.2;\nreturn parentValue * 0.5;`,
            gradientMode: 'custom',
            gradientCustom: { min: -2, max: 2 },
            colorLogic: defaultColorLogicSource,
            hdrLogic: defaultHdrLogicSource,
        },
        decay: {
            moves: `[[1, -1], [1, 1]]`,
            logic: `return parentValue * 0.8;`,
            gradientMode: 'positive',
            colorLogic: defaultColorLogicSource,
            hdrLogic: defaultHdrLogicSource,
        },
        sierpinski: {
            moves: `[[1, -1], [1, 1]]`,
            logic: `const parity = Math.abs(Math.round(parentValue)) % 2;\nreturn parity;`,
            gradientMode: 'custom',
            gradientCustom: { min: 0, max: 2 },
            colorLogic: `const parity = Math.abs(Math.round(value)) % 2;\nif (parity === 1) {\n    return 'rgb(64, 214, 204)';\n}\nreturn 'rgb(15, 18, 30)';`,
            hdrLogic: defaultHdrLogicSource,
            generations: 180,
            reunification: 'sum',
        },
    };

    function loadPreset(preset) {
        if (Number.isFinite(preset.generations)) {
            controls.generations.value = preset.generations;
        }
        if (typeof preset.reunification === 'string') {
            controls.reunification.value = preset.reunification;
        }
        controls.moves.value = preset.moves;
        setCodeValue('propagationLogic', preset.logic);
        controls.gradientMode.value = preset.gradientMode || 'symmetric';
        if (controls.gradientMode.value === 'custom' && preset.gradientCustom) {
            controls.gradientMin.value = preset.gradientCustom.min;
            controls.gradientMax.value = preset.gradientCustom.max;
        }
        setCodeValue('colorLogic', preset.colorLogic || defaultColorLogicSource);
        setCodeValue('hdrLogic', preset.hdrLogic || defaultHdrLogicSource);
        toggleCustomGradientInputs();
        scheduleRun();
    }

    // --- Event Listeners ---
    ['generations', 'reunification', 'moves', 'gradientMin', 'gradientMax'].forEach(id => {
        document.getElementById(id).addEventListener('input', scheduleRun);
    });

    controls.gradientMode.addEventListener('change', () => {
        toggleCustomGradientInputs();
        scheduleRun();
    });

    controls.saveProjectBtn.onclick = saveProject;
    controls.loadProjectSelect.onchange = loadProject;
    controls.deleteProjectBtn.onclick = deleteProject;
    controls.presetPascal.onclick = () => loadPreset(presets.pascal);
    controls.presetDivergent.onclick = () => loadPreset(presets.divergent);
    controls.presetBackwards.onclick = () => loadPreset(presets.backwards);
    controls.presetDecay.onclick = () => loadPreset(presets.decay);
    controls.presetSierpinski.onclick = () => loadPreset(presets.sierpinski);
    controls.inspectorCloseBtn.onclick = () => { inspectorPanel.style.display = 'none'; selectedNodeKey = null; drawGrid(); };
    inspectorPanel.addEventListener('click', (event) => {
        const target = event.target instanceof Element ? event.target.closest('.inspector-node-link') : null;
        if (!target) return;
        const nodeKey = target.dataset.nodeKey;
        if (!nodeKey || !grid.has(nodeKey)) return;
        selectedNodeKey = nodeKey;
        updateInspectorPanel(nodeKey);
        drawGrid();
    });
    inspectorPanel.addEventListener('keydown', (event) => {
        if (event.defaultPrevented) return;
        if (event.key !== 'Enter' && event.key !== ' ') return;
        const target = event.target;
        if (!target.classList || !target.classList.contains('inspector-node-link')) return;
        event.preventDefault();
        const nodeKey = target.dataset.nodeKey;
        if (!nodeKey || !grid.has(nodeKey)) return;
        selectedNodeKey = nodeKey;
        updateInspectorPanel(nodeKey);
        drawGrid();
    });
    
    canvas.addEventListener('mousedown', e => { view.isDragging = true; view.lastX = e.clientX; view.lastY = e.clientY; });
    canvas.addEventListener('mouseup', () => { view.isDragging = false; canvas.style.cursor = 'grab'; });
    canvas.addEventListener('mouseleave', () => { view.isDragging = false; canvas.style.cursor = 'grab'; });
    canvas.addEventListener('mousemove', e => {
        if (!view.isDragging) return;
        canvas.style.cursor = 'grabbing';
        view.offsetX += e.clientX - view.lastX;
        view.offsetY += e.clientY - view.lastY;
        view.lastX = e.clientX;
        view.lastY = e.clientY;
        drawGrid();
    });
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const scaleAmount = e.deltaY < 0 ? 1.1 : 1 / 1.1;
        view.scale *= scaleAmount;
        drawGrid();
    });
    canvas.addEventListener('click', e => {
        if (Math.abs(e.clientX - view.lastX) < 3 && Math.abs(e.clientY - view.lastY) < 3) {
            selectedNodeKey = findNodeAt(e.clientX, e.clientY);
            updateInspectorPanel(selectedNodeKey);
            drawGrid();
        }
    });

    // --- Initial Load ---
    updateProjectList();
    toggleCustomGradientInputs();
    run();
});
</script>

</body>
</html>
