<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Grid Propagation Simulator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/lib/codemirror.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/theme/darcula.min.css">
    <style>
        :root {
            --bg-color: #1a1a1d;
            --panel-bg: #2c2c34;
            --text-color: #f0f0f0;
            --primary-color: #4c82f7;
            --border-color: #444;
            --input-bg: #3a3a44;
            --error-color: #e57373;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        #main-container {
            display: flex;
            flex-grow: 1;
            min-width: 0;
        }

        #controls {
            width: 450px;
            min-width: 260px;
            max-width: 720px;
            padding: 15px;
            background-color: var(--panel-bg);
            border-right: 2px solid var(--border-color);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #sidebarResizer {
            flex: 0 0 6px;
            width: 6px;
            cursor: col-resize;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0));
            border-left: 1px solid rgba(255, 255, 255, 0.08);
            border-right: 1px solid rgba(0, 0, 0, 0.35);
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: var(--bg-color);
            cursor: grab;
            min-width: 0;
        }
        #canvas-container:active { cursor: grabbing; }

        #gridCanvas { 
            display: block; 
            width: 100%;
            height: 100%;        
        }
        
        .control-group {
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 5px;
        }

        .control-group h3 {
            margin-top: 0;
            font-size: 1em;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        
        label { display: block; margin-bottom: 5px; font-size: 0.9em; }

        input, select, textarea, button {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        
        textarea { font-family: "Courier New", monospace; resize: vertical; }

        .editor-container { position: relative; }
        .CodeMirror {
            height: auto;
            background-color: var(--input-bg);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 0.9em;
        }
        .CodeMirror-scroll {
            padding-bottom: 8px;
        }
        .editor-error {
            box-shadow: 0 0 0 1px var(--error-color);
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #6a9eff; }

        .button-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .storage-buttons { display: flex; gap: 10px; }
        #deleteProjectBtn { background-color: #c94c4c; }
        #deleteProjectBtn:hover { background-color: #e06c6c; }

        body.resizing-horizontal,
        body.resizing-vertical {
            user-select: none;
        }
        body.resizing-horizontal { cursor: col-resize; }
        body.resizing-vertical { cursor: row-resize; }

        #codeEditorPanel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #codeEditorPanel.collapsed {
            gap: 0;
        }
        .editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .editor-header h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        .editor-toggle {
            width: auto;
            padding: 6px 12px;
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }
        .editor-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .editor-tabs {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .editor-tab {
            width: auto;
            flex: 1;
            padding: 6px 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-color);
            font-size: 0.9em;
            transition: background-color 0.15s, border-color 0.15s;
        }
        .editor-tab.active {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        .editor-tab:not(.active):hover {
            background-color: rgba(255, 255, 255, 0.12);
        }
        .editor-content {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 240px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--input-bg);
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        .editor-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .editor-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .editor-section-header h4 {
            margin: 0;
            font-size: 0.95em;
            color: rgba(255, 255, 255, 0.85);
            font-weight: 600;
        }
        .editor-panes {
            position: relative;
            min-height: 300px;
        }
        #codeEditorPanel.collapsed .editor-tabs,
        #codeEditorPanel.collapsed .editor-content,
        #codeEditorPanel.collapsed .editor-section,
        #codeEditorPanel.collapsed .editor-resizer {
            display: none;
        }
        .editor-pane {
            position: absolute;
            inset: 0;
            display: none;
            padding: 8px;
            box-sizing: border-box;
            flex-direction: column;
            gap: 6px;
            background-color: rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 4px;
        }
        .editor-pane.active {
            display: flex;
        }
        .editor-pane label {
            margin-bottom: 0;
            font-size: 0.85em;
            opacity: 0.85;
        }
        .editor-pane .CodeMirror {
            flex: 1;
            height: 100%;
        }
        .editor-resizer {
            height: 10px;
            cursor: row-resize;
            border: 1px solid rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.02));
        }
        .editor-resizer:hover {
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.28), rgba(255, 255, 255, 0.06));
        }

        #inspector-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(44, 44, 52, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            color: var(--text-color);
            font-size: 0.9em;
            display: none; /* Hidden by default */
            width: 300px;
            pointer-events: auto;

            max-height: 90vh;
        }
        #inspector-panel .close-btn {
            position: absolute;
            top: 5px; right: 8px;
            cursor: pointer; font-weight: bold;
            pointer-events: auto;
        }
        #inspector-panel h5 {
            margin: 10px 0 6px;
            font-size: 0.85em;
            color: var(--primary-color);
        }
        .inspector-node-links {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-left: 4px;
            min-width: 0;
        }
        .inspector-node-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: rgba(255, 255, 255, 0.08);
            cursor: pointer;
            color: inherit;
            font-size: 0.85em;
            pointer-events: auto;
            user-select: none;
        }
        .inspector-node-link:hover,
        .inspector-node-link:focus {
            background-color: rgba(76, 130, 247, 0.2);
            border-color: var(--primary-color);
            outline: none;
        }
        .inspector-section {
            margin-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: 8px;            
        }
        .inspector-section.hidden {
            display: none;
        }
        .binary-stat {
            display: block;
            margin-bottom: 4px;
            overflow-x: scroll;
        }
        .binary-distribution {
            font-size: 0.85em;
            line-height: 1.35;
            margin: 6px 0;            
        }

        .binary-flex {
            overflow-y: auto;
            overflow-x: auto;
            max-height: min(240px, 40vh);
            padding-right: 4px;
        }

        .binary-sample {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 4px;                          
        }
        .binary-sample code {
            background-color: rgba(255, 255, 255, 0.08);
            padding: 2px 4px;
            border-radius: 3px;
        }
        .binary-note {
            font-size: 0.8em;
            opacity: 0.8;
            margin-top: 4px;
        }
        #binaryHoverPopup {
            position: fixed;
            z-index: 1000;
            max-width: 280px;
            background-color: rgba(32, 32, 40, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            color: var(--text-color);
            font-size: 0.85em;
            pointer-events: none;
            display: none;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }
        #binaryHoverPopup h5 {
            margin: 0 0 6px 0;
            font-size: 0.95em;
            color: var(--primary-color);
        }

        #customGradientInputs {
            display: none;
            gap: 10px;
        }
        #customGradientInputs input {
            width: calc(50% - 5px);
        }
        #backpropRunStatus {
            display: none;
            margin-top: 6px;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            background-color: rgba(255, 204, 128, 0.18);
            color: #ffd891;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        #backpropRunStatus.visible {
            display: block;
        }
        #backpropRunStatus.pending {
            background-color: rgba(255, 204, 128, 0.24);
            color: #ffe0a8;
        }
        #backpropRunStatus.applied {
            background-color: rgba(76, 130, 247, 0.2);
            color: var(--text-color);
            animation: backpropFlash 1.1s ease forwards;
        }
        @keyframes backpropFlash {
            0% {
                background-color: rgba(76, 130, 247, 0.45);
                color: #ffffff;
            }
            100% {
                background-color: rgba(76, 130, 247, 0.12);
                color: var(--primary-color);
            }
        }
        .backprop-highlight {
            animation: backpropPanePulse 1s ease;
        }
        @keyframes backpropPanePulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 130, 247, 0.45);
                background-color: rgba(76, 130, 247, 0.18);
            }
            100% {
                box-shadow: 0 0 0 22px rgba(76, 130, 247, 0);
                background-color: transparent;
            }
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="controls">
            <h2>Propagation Controls</h2>
            
            <div class="control-group">
                <h3>Simulation Core</h3>
                <label for="generations">Generations</label>
                <input type="number" id="generations" value="100" min="1" max="10000">
                <label for="reunification">Reunification Logic</label>
                <select id="reunification">
                    <option value="sum" selected>Sum</option>
                    <option value="average">Average</option>
                    <option value="max">Maximum</option>
                    <option value="personalized">Custom</option>
                </select>
                <label for="backpropSteps">Backpropagation Steps (optional)</label>
                <input type="number" id="backpropSteps" value="0" min="0" max="50" step="1">
                <div id="backpropRunStatus" role="status" aria-live="polite" aria-atomic="true"></div>
            </div>

            <div class="control-group">
                <h3>Propagation Rules</h3>
                <label for="moves">Move Vectors [dx, dy]</label>
                <textarea id="moves">[[1, -1], [1, 1]]</textarea>
            </div>

            <div class="control-group">
                <h3>Projection</h3>
                <label for="projectionMode">Projection Mode</label>
                <select id="projectionMode">
                    <option value="grid" selected>Grid (planar)</option>
                    <option value="isometric">Isometric</option>
                    <option value="custom">Custom JS</option>
                </select>
            </div>

            <div class="control-group" id="codeEditorPanel">
                <div class="editor-header">
                    <h3>Logic Editors</h3>
                    <button type="button" class="editor-toggle" id="editorToggleBtn" aria-expanded="true">Hide Editors</button>
                </div>
                <div class="editor-content" id="codeEditorContent">
                    <section class="editor-section" data-editor-group="propagation">
                        <div class="editor-section-header">
                            <h4>Propagation Dimensions</h4>
                            <div class="editor-tabs">
                                <button type="button" class="editor-tab active" data-target-editor="propagationPrimaryLogic">Primary</button>
                                <button type="button" class="editor-tab" data-target-editor="propagationSecondaryLogic">Secondary</button>
                            </div>
                        </div>
                        <div class="editor-panes">
                            <div class="editor-pane active" data-editor-pane="propagationPrimaryLogic">
                                <label for="propagationPrimaryLogic">Primary Dimension(parentValue, parentDimensions, index, move, context)</label>
                                <textarea id="propagationPrimaryLogic">// 'Left' branch (index 0) gains value, 'right' loses.
const base = parentValue;
const delta = index === 0 ? 0.2 : -0.3;
return { value: base + delta, isActive: true };</textarea>
                            </div>
                            <div class="editor-pane" data-editor-pane="propagationSecondaryLogic">
                                <label for="propagationSecondaryLogic">Secondary Dimension(parentValue, parentDimensions, index, move, context)</label>
                                <textarea id="propagationSecondaryLogic">const primary = parentDimensions.primary?.value ?? parentValue;
const magnitude = Math.abs(primary);
if (magnitude > 1.5) {
    const bias = index === 0 ? 0.12 : -0.08;
    return {
        value: primary * 0.3 + bias,
        isActive: true,
        meta: { reason: 'high-magnitude' },
    };
}
return null;</textarea>
                            </div>
                        </div>
                    </section>
                    <section class="editor-section" data-editor-group="composition">
                        <div class="editor-section-header">
                            <h4>Propagation Composition</h4>
                            <div class="editor-tabs">
                                <button type="button" class="editor-tab active" data-target-editor="effectiveValueLogic">Effective Value</button>
                                <button type="button" class="editor-tab" data-target-editor="backpropLogic">Backpropagation</button>
                                <button type="button" class="editor-tab" data-target-editor="backpropFillLogic">Backprop Fill</button>
                            </div>
                        </div>
                        <div class="editor-panes">
                            <div class="editor-pane active" data-editor-pane="effectiveValueLogic">
                                <label for="effectiveValueLogic">Effective Final Value Function(dimensions, context)</label>
                                <textarea id="effectiveValueLogic">const primary = dimensions.primary?.value ?? 0;
const secondary = (dimensions.secondary?.isActive ? dimensions.secondary.value : 0);
return primary + secondary;</textarea>
                            </div>
                            <div class="editor-pane" data-editor-pane="backpropLogic">
                                <label for="backpropLogic">Backpropagation Function(childState, parentState, context)</label>
                                <textarea id="backpropLogic">const delta = (childState.value - parentState.value) * 0.25;
return {
    parent: { valueDelta: delta },
    child: { valueDelta: -delta * 0.25 },
};</textarea>
                            </div>
                            <div class="editor-pane" data-editor-pane="backpropFillLogic">
                                <label for="backpropFillLogic">Backprop Fill Helper(childState, parentState, context)</label>
                                <textarea id="backpropFillLogic">return null;</textarea>
                            </div>
                        </div>
                    </section>
                    <section class="editor-section" data-editor-group="reunification" id="reunificationEditorSection" style="display: none;">
                        <div class="editor-section-header">
                            <h4>Custom Reunification</h4>
                        </div>
                        <div class="editor-panes">
                            <div class="editor-pane active" data-editor-pane="reunificationLogic">
                                <label for="reunificationLogic">Reunification Function(values, context)</label>
                                <textarea id="reunificationLogic">// values: number[]; context: { count, sum, average, min, max }
const { sum } = context;
return sum;</textarea>
                            </div>
                        </div>
                    </section>
                    <section class="editor-section" data-editor-group="visualization">
                        <div class="editor-section-header">
                            <h4>Visualization Logic</h4>
                            <div class="editor-tabs">
                                <button type="button" class="editor-tab active" data-target-editor="colorLogic">Color</button>
                                <button type="button" class="editor-tab" data-target-editor="hdrLogic">HDR</button>
                            </div>
                        </div>
                        <div class="editor-panes">
                            <div class="editor-pane active" data-editor-pane="colorLogic">
                                <label for="colorLogic">Color Logic Function(value, stats, range, context)</label>
                                <textarea id="colorLogic">const clamp01 = (num) => Math.min(Math.max(num, 0), 1);
const safeMax = range.max > 0 ? range.max : 1;
const safeMin = range.min < 0 ? range.min : -1;
const viewScale = (context && typeof context.scale === 'number') ? context.scale : 1;
const intensity = viewScale < 1 ? Math.min(1.6, Math.pow(1 / Math.max(viewScale, 0.0001), 0.3)) : 1;
const applyHDR = (context && typeof context.applyHDR === 'function')
    ? context.applyHDR
    : ((input) => clamp01(input.ratio));

const sampleStops = (stops, ratio) => {
    const clamped = clamp01(ratio);
    if (clamped <= stops[0].stop) return stops[0].rgb.slice();
    for (let i = 0; i < stops.length - 1; i++) {
        const left = stops[i];
        const right = stops[i + 1];
        if (clamped >= left.stop && clamped <= right.stop) {
            const span = right.stop - left.stop || 1;
            const t = (clamped - left.stop) / span;
            return left.rgb.map((channel, idx) =>
                Math.round(channel + (right.rgb[idx] - channel) * t)
            );
        }
    }
    return stops[stops.length - 1].rgb.slice();
};

const enhanceRatio = (ratio) => clamp01(Math.pow(clamp01(ratio), 1 / intensity));
const toCss = (rgb) => `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;

const positiveStops = [
    { stop: 0, rgb: [255, 250, 165] },
    { stop: 0.33, rgb: [253, 197, 110] },
    { stop: 0.66, rgb: [244, 109, 67] },
    { stop: 1, rgb: [180, 23, 44] },
];
const negativeStops = [
    { stop: 0, rgb: [194, 230, 255] },
    { stop: 0.33, rgb: [123, 190, 222] },
    { stop: 0.66, rgb: [50, 136, 189] },
    { stop: 1, rgb: [3, 52, 118] },
];

if (value >= 0) {
    const hdrRatio = applyHDR({ ratio: value / safeMax, value, stats, range, polarity: 'positive', scale: viewScale });
    const ratio = enhanceRatio(hdrRatio);
    return toCss(sampleStops(positiveStops, ratio));
}
const hdrRatio = applyHDR({ ratio: Math.abs(value / safeMin), value, stats, range, polarity: 'negative', scale: viewScale });
const ratio = enhanceRatio(hdrRatio);
return toCss(sampleStops(negativeStops, ratio));</textarea>
                            </div>
                            <div class="editor-pane" data-editor-pane="hdrLogic">
                                <label for="hdrLogic">HDR Mapping Function(input, context)</label>
                                <textarea id="hdrLogic">const clamp01 = (num) => Math.min(Math.max(num, 0), 1);
const { ratio, scale } = input;
const base = clamp01(ratio);
const shoulder = Math.log1p(base * 8) / Math.log1p(8);
const gamma = Math.pow(base, 0.025);
const mix = 0.9;
let result = (1 - mix) * shoulder + mix * gamma;
if (scale && scale < 1) {
    result *= Math.min(1.45, Math.pow(1 / Math.max(scale, 0.0001), 0.12));
}
return clamp01(result);</textarea>
                            </div>
                        </div>
                    </section>
                    <section class="editor-section" data-editor-group="spatial">
                        <div class="editor-section-header">
                            <h4>Spatial Mapping</h4>
                            <div class="editor-tabs">
                                <button type="button" class="editor-tab active" data-target-editor="positionLogic">Projection</button>
                                <button type="button" class="editor-tab" data-target-editor="spaceDistortionLogic">Space Distortion</button>
                            </div>
                        </div>
                        <div class="editor-panes">
                            <div class="editor-pane active" data-editor-pane="positionLogic">
                                <label for="positionLogic">Position Logic Function(key, coords, node, context)</label>
                                <textarea id="positionLogic">// Return { x, y, z? } to override node projection. context.node exposes full state snapshot.
const nodeState = node || {};
const generation = nodeState.gen ?? context.generation ?? 0;
const zetaValue = nodeState.value ?? 0;
const baseX = coords.x;
const cluster = baseX * 0.12;
const spread = Math.log2(generation + 2);
return {
    x: generation * 1.15 + cluster,
    y: -zetaValue * 0.9,
    z: 0,
};</textarea>
                            </div>
                            <div class="editor-pane" data-editor-pane="spaceDistortionLogic">
                                <label for="spaceDistortionLogic">Space Distortion Function(baseResult, context)</label>
                                <textarea id="spaceDistortionLogic">// baseResult is the normalized dimension payload { value, isActive, contributors, meta? }.
// Return null to drop the contribution, a number/object to replace it, or undefined to keep it.
if (!baseResult) return null;
const { childCoords, generation, dimensionKey } = context;
const radius = Math.hypot(childCoords.x, childCoords.y);
const oscillation = Math.sin(radius * 0.06 + generation * 0.08);
const scaling = 1 + oscillation * (dimensionKey === 'primary' ? 0.35 : 0.15);
return {
    ...baseResult,
    value: baseResult.value * scaling,
};</textarea>
                            </div>
                        </div>
                    </section>
                </div>
                <div class="editor-resizer" id="editorResizer" title="Drag to resize editors"></div>
            </div>

            <div class="control-group">
                <h3>Visualization</h3>
                <label for="gradientMode">Gradient Scale</label>
                <select id="gradientMode">
                    <option value="symmetric" selected>Symmetric ±max</option>
                    <option value="positive">0 → max</option>
                    <option value="negative">min → 0</option>
                    <option value="custom">Custom range</option>
                </select>
                <div id="customGradientInputs">
                    <input type="number" id="gradientMin" placeholder="Min (e.g., -1)" step="0.1" value="-1">
                    <input type="number" id="gradientMax" placeholder="Max (e.g., 1)" step="0.1" value="1">
                </div>
                <label for="xDistributionScale">X-Axis Distribution (<span id="xDistributionScaleValue">1.00x</span>)</label>
                <input type="range" id="xDistributionScale" min="0.05" max="3" step="0.05" value="1">
            </div>
            
            <div class="control-group">
                <h3>Presets</h3>
                <div class="button-grid">
                    <button id="presetPascal">Pascal</button>
                    <button id="presetDivergent">Divergent</button>
                    <button id="presetBackwards">Echo</button>
                    <button id="presetDecay">Decay</button>
                    <button id="presetSierpinski">Sierpinski</button>
                    <button id="presetSierpinskiZeta">Sierpinski-Zeta</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Projects (Local Storage)</h3>
                <input type="text" id="projectName" placeholder="My Divergent Model">
                <div class="storage-buttons">
                    <button id="saveProjectBtn">Save</button>
                    <button id="deleteProjectBtn">Delete</button>
                </div>
                <select id="loadProjectSelect"></select>
            </div>
        </div>
        <div id="sidebarResizer" role="separator" aria-orientation="vertical" aria-label="Resize controls panel"></div>
        <div id="canvas-container">
            <canvas id="gridCanvas"></canvas>
            <div id="inspector-panel">
                <span class="close-btn" id="inspector-close-btn">&times;</span>
                <h4>Node Inspector</h4>
                <p><strong>Coords:</strong> <span id="inspector-coords"></span></p>
                <p><strong>Value:</strong> <span id="inspector-value"></span></p>
                <p><strong>Generation:</strong> <span id="inspector-gen"></span></p>
                <p><strong>Parents:</strong> <span id="inspector-parents" class="inspector-node-links"></span></p>
                <p><strong>Children:</strong> <span id="inspector-children" class="inspector-node-links"></span></p>
                <div id="inspector-binary-section" class="inspector-section hidden">
                    <h5>Binary Paths</h5>
                    <div id="inspector-binary-content"></div>
                </div>
            </div>
        </div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/mode/javascript/javascript.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/addon/edit/closebrackets.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.15/addon/selection/active-line.min.js"></script>
<script>

const ENABLE_HOVER_ENUMERATION_POPUP = false; // Set true to enable binary hover popups.
const ENUMERATION_SAMPLE_LIMIT = 32;

class Debouncer {
    constructor(delay, callback) {
        this.delay = delay;
        this.callback = callback;
        this.handle = null;
    }

    trigger(...args) {
        if (this.handle) {
            clearTimeout(this.handle);
        }
        this.handle = setTimeout(() => {
            this.handle = null;
            this.callback(...args);
        }, this.delay);
    }

    cancel() {
        if (this.handle) {
            clearTimeout(this.handle);
            this.handle = null;
        }
    }
}

const GRID_WORKER_SUPPORTED = typeof Worker !== 'undefined';
const GRID_WORKER_URL = 'grid-compute-worker.js';
const GRID_WORKER_IDLE_TIMEOUT_MS = 120000;

class GridWorkerBridge {
    constructor({ url = GRID_WORKER_URL, onResult = null, onError = null } = {}) {
        this.url = url;
        this.onResult = onResult;
        this.onError = onError;
        this.worker = null;
        this.pending = new Map();
        this.idCounter = 0;
        this.idleTimer = null;
        this.disposed = false;
    }

    ensureWorker() {
        if (this.disposed) return null;
        if (!GRID_WORKER_SUPPORTED) return null;
        if (this.worker) return this.worker;
        try {
            this.worker = new Worker(this.url, { name: 'grid-compute-worker' });
            this.worker.onmessage = (event) => this.handleMessage(event);
            this.worker.onerror = (event) => this.handleError(event);
            return this.worker;
        } catch (error) {
            this.worker = null;
            console.warn('Failed to initialise grid worker', error);
            if (typeof this.onError === 'function') {
                this.onError(null, error);
            }
            return null;
        }
    }

    handleMessage(event) {
        const data = event.data || {};
        const requestId = data.requestId;
        if (data.type === 'result') {
            this.resolveRequest(requestId, data.result);
            if (typeof this.onResult === 'function') {
                this.onResult(requestId, data.result);
            }
            this.scheduleIdleTermination();
            return;
        }
        if (data.type === 'error') {
            const error = new Error(data.error?.message || 'Grid worker error');
            if (data.error?.stack) error.stack = data.error.stack;
            this.rejectRequest(requestId, error);
            if (typeof this.onError === 'function') {
                this.onError(requestId, error);
            }
            this.scheduleIdleTermination();
        }
    }

    handleError(event) {
        const error = event instanceof ErrorEvent
            ? event.error || new Error(event.message || 'Grid worker runtime error')
            : new Error('Grid worker runtime error');
        this.rejectAll(error);
        if (typeof this.onError === 'function') {
            this.onError(null, error);
        }
        this.terminate();
    }

    compute(payload) {
        const worker = this.ensureWorker();
        if (!worker) {
            return Promise.reject(new Error('Grid worker unavailable'));
        }
        const requestId = `${Date.now()}-${++this.idCounter}`;
        return new Promise((resolve, reject) => {
            this.pending.set(requestId, { resolve, reject });
            try {
                worker.postMessage({ type: 'compute', requestId, payload });
                if (this.idleTimer) {
                    clearTimeout(this.idleTimer);
                    this.idleTimer = null;
                }
            } catch (error) {
                this.pending.delete(requestId);
                reject(error);
                if (typeof this.onError === 'function') {
                    this.onError(requestId, error);
                }
            }
        });
    }

    resolveRequest(requestId, result) {
        if (!requestId || !this.pending.has(requestId)) return;
        const entry = this.pending.get(requestId);
        this.pending.delete(requestId);
        if (entry && typeof entry.resolve === 'function') {
            entry.resolve(result);
        }
    }

    rejectRequest(requestId, error) {
        if (!requestId || !this.pending.has(requestId)) return;
        const entry = this.pending.get(requestId);
        this.pending.delete(requestId);
        if (entry && typeof entry.reject === 'function') {
            entry.reject(error);
        }
    }

    rejectAll(error) {
        this.pending.forEach((entry) => {
            if (entry && typeof entry.reject === 'function') {
                entry.reject(error);
            }
        });
        this.pending.clear();
    }

    scheduleIdleTermination() {
        if (this.idleTimer) {
            clearTimeout(this.idleTimer);
        }
        this.idleTimer = setTimeout(() => this.terminate(), GRID_WORKER_IDLE_TIMEOUT_MS);
    }

    terminate() {
        if (this.worker) {
            try {
                this.worker.terminate();
            } catch (error) {
                console.warn('Failed to terminate grid worker cleanly', error);
            }
            this.worker = null;
        }
        if (this.idleTimer) {
            clearTimeout(this.idleTimer);
            this.idleTimer = null;
        }
    }

    dispose() {
        this.disposed = true;
        this.terminate();
        this.pending.clear();
    }
}

class GridSimulatorApp {
    constructor(document) {

        const app = this;
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const inspectorPanel = document.getElementById('inspector-panel');
        const inspectorFields = {
            coords: document.getElementById('inspector-coords'),
            value: document.getElementById('inspector-value'),
            gen: document.getElementById('inspector-gen'),
            parents: document.getElementById('inspector-parents'),
            children: document.getElementById('inspector-children'),
            binarySection: document.getElementById('inspector-binary-section'),
            binaryContent: document.getElementById('inspector-binary-content'),
        };
        this.document = document;
        this.canvas = canvas;
        this.ctx = ctx;
        this.inspectorPanel = inspectorPanel;
        this.inspectorFields = inspectorFields;
        const controls = {
            generations: document.getElementById('generations'),
            reunification: document.getElementById('reunification'),
            reunificationLogic: document.getElementById('reunificationLogic'),
            backpropSteps: document.getElementById('backpropSteps'),
            moves: document.getElementById('moves'),
            propagationPrimary: document.getElementById('propagationPrimaryLogic'),
            propagationSecondary: document.getElementById('propagationSecondaryLogic'),
            effectiveValueLogic: document.getElementById('effectiveValueLogic'),
            backpropLogic: document.getElementById('backpropLogic'),
            backpropFillLogic: document.getElementById('backpropFillLogic'),
            projectName: document.getElementById('projectName'),
            saveProjectBtn: document.getElementById('saveProjectBtn'),
            deleteProjectBtn: document.getElementById('deleteProjectBtn'),
            loadProjectSelect: document.getElementById('loadProjectSelect'),
            presetPascal: document.getElementById('presetPascal'),
            presetDivergent: document.getElementById('presetDivergent'),
            presetBackwards: document.getElementById('presetBackwards'),
            presetDecay: document.getElementById('presetDecay'),
            presetSierpinski: document.getElementById('presetSierpinski'),
            presetSierpinskiZeta: document.getElementById('presetSierpinskiZeta'),
            inspectorCloseBtn: document.getElementById('inspector-close-btn'),
            gradientMode: document.getElementById('gradientMode'),
            gradientMin: document.getElementById('gradientMin'),
            gradientMax: document.getElementById('gradientMax'),
            colorLogic: document.getElementById('colorLogic'),
            hdrLogic: document.getElementById('hdrLogic'),
            positionLogic: document.getElementById('positionLogic'),
            spaceDistortionLogic: document.getElementById('spaceDistortionLogic'),
            projectionMode: document.getElementById('projectionMode'),
            xDistributionScale: document.getElementById('xDistributionScale'),
            xDistributionLabel: document.getElementById('xDistributionScaleValue'),
        };
        this.controls = controls;
        const backpropNotificationEl = document.getElementById('backpropRunStatus');
        const backpropEditorPanes = Array.from(document.querySelectorAll('.editor-pane[data-editor-pane="backpropLogic"], .editor-pane[data-editor-pane="backpropFillLogic"]'));
        const backpropNotificationState = {
            pending: false,
            reason: null,
            timeoutHandle: null,
        };
        this.backpropNotificationEl = backpropNotificationEl;
        this.backpropEditorPanes = backpropEditorPanes;
        const controlsPanel = document.getElementById('controls');
        const editorPanel = document.getElementById('codeEditorPanel');
        const editorContent = document.getElementById('codeEditorContent');
        const editorToggleBtn = document.getElementById('editorToggleBtn');
        const editorResizer = document.getElementById('editorResizer');
        const sidebarResizer = document.getElementById('sidebarResizer');
        const editorSections = Array.from(document.querySelectorAll('.editor-section[data-editor-group]'));
        this.controlsPanel = controlsPanel;
        this.editorPanel = editorPanel;
        this.editorContent = editorContent;
        this.editorToggleBtn = editorToggleBtn;
        this.editorResizer = editorResizer;
        this.sidebarResizer = sidebarResizer;
        this.editorSections = editorSections;

        const STORAGE_KEYS = {
            editorHeight: 'gridSimEditorHeight',
            sidebarWidth: 'gridSimSidebarWidth',
            editorCollapsed: 'gridSimEditorCollapsed',
        };
        this.STORAGE_KEYS = STORAGE_KEYS;
        const MIN_EDITOR_HEIGHT = 160;
        const MAX_EDITOR_HEIGHT = 640;
        const MIN_SIDEBAR_WIDTH = 260;
        const MAX_SIDEBAR_WIDTH = 720;
        this.MIN_EDITOR_HEIGHT = MIN_EDITOR_HEIGHT;
        this.MAX_EDITOR_HEIGHT = MAX_EDITOR_HEIGHT;
        this.MIN_SIDEBAR_WIDTH = MIN_SIDEBAR_WIDTH;
        this.MAX_SIDEBAR_WIDTH = MAX_SIDEBAR_WIDTH;

        const clampNumber = (value, min, max) => Math.min(Math.max(value, min), max);

        function updateXDistributionLabel(value) {
            if (!controls.xDistributionLabel) return;
            const numeric = Number(value);
            const display = Number.isFinite(numeric) ? numeric : 1;
            controls.xDistributionLabel.textContent = `${display.toFixed(2)}x`;
        }

        let editorHeight = 240;
        let isEditorCollapsed = false;
        let binaryEnumerationSupported = false;
        let binaryHoverPopup = null;
        let currentHoverNodeKey = null;
        this.editorHeight = editorHeight;
        this.isEditorCollapsed = isEditorCollapsed;
        this.binaryEnumerationSupported = binaryEnumerationSupported;
        this.binaryHoverPopup = binaryHoverPopup;
        this.currentHoverNodeKey = currentHoverNodeKey;

        const editorGroups = new Map();
        this.editorGroups = editorGroups;

        if (editorContent) {
            const storedHeight = parseInt(localStorage.getItem(STORAGE_KEYS.editorHeight), 10);
            if (Number.isFinite(storedHeight)) {
                editorHeight = clampNumber(storedHeight, MIN_EDITOR_HEIGHT, MAX_EDITOR_HEIGHT);
            } else {
                editorHeight = clampNumber(editorContent.offsetHeight || editorHeight, MIN_EDITOR_HEIGHT, MAX_EDITOR_HEIGHT);
            }
            app.editorHeight = editorHeight;
            editorContent.style.height = `${editorHeight}px`;
        }

        if (editorPanel) {
            isEditorCollapsed = localStorage.getItem(STORAGE_KEYS.editorCollapsed) === 'true';
            app.isEditorCollapsed = isEditorCollapsed;
            if (isEditorCollapsed) {
                editorPanel.classList.add('collapsed');
                if (editorToggleBtn) {
                    editorToggleBtn.textContent = 'Show Editors';
                    editorToggleBtn.setAttribute('aria-expanded', 'false');
                }
            } else if (editorToggleBtn) {
                editorToggleBtn.setAttribute('aria-expanded', 'true');
            }
        }

        if (controlsPanel) {
            const storedWidth = parseInt(localStorage.getItem(STORAGE_KEYS.sidebarWidth), 10);
            if (Number.isFinite(storedWidth)) {
                controlsPanel.style.width = `${clampNumber(storedWidth, MIN_SIDEBAR_WIDTH, MAX_SIDEBAR_WIDTH)}px`;
            }
        }

        const customGradientInputs = document.getElementById('customGradientInputs');
        const reunificationEditorSection = document.getElementById('reunificationEditorSection');
        const spatialEditorSection = document.querySelector('.editor-section[data-editor-group="spatial"]');
        const codeEditors = {};
        this.customGradientInputs = customGradientInputs;
        this.reunificationEditorSection = reunificationEditorSection;
        this.spatialEditorSection = spatialEditorSection;
        this.codeEditors = codeEditors;
        const defaultColorLogicSource = controls.colorLogic.value;
        const defaultHdrLogicSource = controls.hdrLogic.value;
        const defaultPropagationSources = {
            primary: controls.propagationPrimary ? controls.propagationPrimary.value : '',
            secondary: controls.propagationSecondary ? controls.propagationSecondary.value : '',
        };
        const defaultPositionLogicSource = controls.positionLogic ? controls.positionLogic.value : '';
        const defaultSpaceDistortionSource = controls.spaceDistortionLogic ? controls.spaceDistortionLogic.value : '';
        const defaultProjectionMode = controls.projectionMode ? controls.projectionMode.value : 'grid';
        const defaultReunificationLogicSource = controls.reunificationLogic ? controls.reunificationLogic.value : '';
        const defaultEffectiveValueSource = controls.effectiveValueLogic ? controls.effectiveValueLogic.value : '';
        const defaultBackpropLogicSource = controls.backpropLogic ? controls.backpropLogic.value : '';
        const defaultBackpropFillLogicSource = controls.backpropFillLogic ? controls.backpropFillLogic.value : '';
        this.defaultColorLogicSource = defaultColorLogicSource;
        this.defaultHdrLogicSource = defaultHdrLogicSource;
        this.defaultPropagationSources = defaultPropagationSources;
        this.defaultPositionLogicSource = defaultPositionLogicSource;
        this.defaultSpaceDistortionSource = defaultSpaceDistortionSource;
        this.defaultProjectionMode = defaultProjectionMode;
        this.defaultReunificationLogicSource = defaultReunificationLogicSource;
        this.defaultEffectiveValueSource = defaultEffectiveValueSource;
        this.defaultBackpropLogicSource = defaultBackpropLogicSource;
        this.defaultBackpropFillLogicSource = defaultBackpropFillLogicSource;

        function getPendingBackpropMessage(reason) {
            switch (reason) {
                case 'steps': return 'Waiting to apply backprop steps...';
                case 'code': return 'Waiting to apply backprop code...';
                case 'mixed': return 'Waiting to apply backprop changes...';
                default: return 'Waiting to apply backprop changes...';
            }
        }

        function getAppliedBackpropMessage(reason) {
            switch (reason) {
                case 'steps': return 'Backprop steps applied';
                case 'code': return 'Backprop code applied';
                case 'mixed': return 'Backprop changes applied';
                default: return 'Backprop changes applied';
            }
        }

        function clearBackpropNotificationTimer() {
            if (!backpropNotificationState.timeoutHandle) return;
            clearTimeout(backpropNotificationState.timeoutHandle);
            backpropNotificationState.timeoutHandle = null;
        }

        function animateBackpropPane() {
            if (!backpropEditorPanes.length) return;
            backpropEditorPanes.forEach((pane) => {
                pane.classList.remove('backprop-highlight');
                // Force reflow per pane to replay animation
                void pane.offsetWidth;
                pane.classList.add('backprop-highlight');
                setTimeout(() => pane.classList.remove('backprop-highlight'), 900);
            });
        }

        function markBackpropPending(reason) {
            clearBackpropNotificationTimer();
            if (backpropNotificationState.pending && backpropNotificationState.reason && backpropNotificationState.reason !== reason) {
                backpropNotificationState.reason = 'mixed';
            } else {
                backpropNotificationState.reason = reason;
            }
            backpropNotificationState.pending = true;
            if (!backpropNotificationEl) return;
            backpropNotificationEl.textContent = getPendingBackpropMessage(backpropNotificationState.reason);
            backpropNotificationEl.classList.add('visible', 'pending');
            backpropNotificationEl.classList.remove('applied');
        }

        function notifyBackpropApplied() {
            if (!backpropNotificationState.pending) return;
            backpropNotificationState.pending = false;
            const reason = backpropNotificationState.reason || 'mixed';
            backpropNotificationState.reason = null;
            if (backpropNotificationEl) {
                backpropNotificationEl.textContent = getAppliedBackpropMessage(reason);
                backpropNotificationEl.classList.remove('pending');
                backpropNotificationEl.classList.add('visible', 'applied');
                clearBackpropNotificationTimer();
                backpropNotificationState.timeoutHandle = setTimeout(() => {
                    if (backpropNotificationEl) {
                        backpropNotificationEl.classList.remove('visible', 'applied');
                        backpropNotificationEl.textContent = '';
                    }
                    backpropNotificationState.timeoutHandle = null;
                }, 1800);
            }
            animateBackpropPane();
        }

        function refreshEditorAfterLayout(editorId) {
            const instance = codeEditors[editorId];
            if (!instance) return;
            requestAnimationFrame(() => instance.refresh());
        }

        function refreshActiveEditors() {
            if (isEditorCollapsed) return;
            editorGroups.forEach(group => {
                if (group.activeId) refreshEditorAfterLayout(group.activeId);
            });
        }

        function ensureEditorExpanded() {
            if (!editorPanel || !editorPanel.classList.contains('collapsed')) return;
            editorPanel.classList.remove('collapsed');
            isEditorCollapsed = false;
            app.isEditorCollapsed = isEditorCollapsed;
            if (editorToggleBtn) {
                editorToggleBtn.textContent = 'Hide Editors';
                editorToggleBtn.setAttribute('aria-expanded', 'true');
            }
            localStorage.setItem(STORAGE_KEYS.editorCollapsed, 'false');
            if (editorContent) editorContent.style.height = `${editorHeight}px`;
            refreshActiveEditors();
        }

        function setActiveEditor(groupName, editorId, options = {}) {
            const group = editorGroups.get(groupName);
            if (!group) return;
            if (!editorId) editorId = group.activeId;
            group.activeId = editorId;
            group.tabs.forEach(tab => {
                const isActive = tab.dataset.targetEditor === editorId;
                tab.classList.toggle('active', isActive);
                tab.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
            group.panes.forEach(pane => {
                const isActive = pane.dataset.editorPane === editorId;
                pane.classList.toggle('active', isActive);
            });
            if (!options.skipRefresh) refreshActiveEditors();
        }

        function initializeEditorGroups() {
            editorSections.forEach(section => {
                const groupName = section.dataset.editorGroup;
                if (!groupName) return;
                const tabs = Array.from(section.querySelectorAll('.editor-tab'));
                const panes = Array.from(section.querySelectorAll('.editor-pane'));
                const defaultActiveId =
                    tabs.find(tab => tab.classList.contains('active'))?.dataset.targetEditor
                    || panes[0]?.dataset.editorPane;
                const group = { section, tabs, panes, activeId: defaultActiveId };
                editorGroups.set(groupName, group);
                if (defaultActiveId) setActiveEditor(groupName, defaultActiveId, { skipRefresh: true });
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const targetId = tab.dataset.targetEditor;
                        if (!targetId) return;
                        ensureEditorExpanded();
                        setActiveEditor(groupName, targetId);
                    });
                });
            });
        }

        if (editorToggleBtn && editorPanel) {
            editorToggleBtn.addEventListener('click', () => {
            const willCollapse = !editorPanel.classList.contains('collapsed');
            editorPanel.classList.toggle('collapsed', willCollapse);
            isEditorCollapsed = willCollapse;
            app.isEditorCollapsed = isEditorCollapsed;
            if (willCollapse) {
                editorToggleBtn.textContent = 'Show Editors';
                editorToggleBtn.setAttribute('aria-expanded', 'false');
            } else {
                    editorToggleBtn.textContent = 'Hide Editors';
                    editorToggleBtn.setAttribute('aria-expanded', 'true');
                    if (editorContent) editorContent.style.height = `${editorHeight}px`;
                    refreshActiveEditors();
                }
                localStorage.setItem(STORAGE_KEYS.editorCollapsed, willCollapse ? 'true' : 'false');
            });
        }

        if (editorResizer && editorContent) {
            let resizingEditors = false;
            let startY = 0;
            let startHeight = editorHeight;

            editorResizer.addEventListener('mousedown', event => {
                if (isEditorCollapsed) return;
                event.preventDefault();
                resizingEditors = true;
                startY = event.clientY;
                startHeight = editorContent.offsetHeight || editorHeight;
                document.body.classList.add('resizing-vertical');
            });

            window.addEventListener('mousemove', event => {
                if (!resizingEditors) return;
            const delta = event.clientY - startY;
            editorHeight = clampNumber(startHeight + delta, MIN_EDITOR_HEIGHT, MAX_EDITOR_HEIGHT);
            app.editorHeight = editorHeight;
            editorContent.style.height = `${editorHeight}px`;
            refreshActiveEditors();
        });

        window.addEventListener('mouseup', () => {
            if (!resizingEditors) return;
            resizingEditors = false;
            document.body.classList.remove('resizing-vertical');
            localStorage.setItem(STORAGE_KEYS.editorHeight, Math.round(editorHeight));
            app.editorHeight = editorHeight;
            refreshActiveEditors();
        });
        }

        if (sidebarResizer && controlsPanel) {
            let resizingSidebar = false;
            let startX = 0;
            let startWidth = controlsPanel.offsetWidth;

            sidebarResizer.addEventListener('mousedown', event => {
                event.preventDefault();
                resizingSidebar = true;
                startX = event.clientX;
                startWidth = controlsPanel.offsetWidth;
                document.body.classList.add('resizing-horizontal');
            });

            window.addEventListener('mousemove', event => {
                if (!resizingSidebar) return;
                const delta = event.clientX - startX;
                const nextWidth = clampNumber(startWidth + delta, MIN_SIDEBAR_WIDTH, MAX_SIDEBAR_WIDTH);
                controlsPanel.style.width = `${nextWidth}px`;
            });

            window.addEventListener('mouseup', () => {
                if (!resizingSidebar) return;
                resizingSidebar = false;
                document.body.classList.remove('resizing-horizontal');
                const storedWidth = clampNumber(Math.round(controlsPanel.offsetWidth), MIN_SIDEBAR_WIDTH, MAX_SIDEBAR_WIDTH);
                localStorage.setItem(STORAGE_KEYS.sidebarWidth, storedWidth);
                drawGrid();
            });
        }

        initializeEditorGroups();
        refreshActiveEditors();

        const positiveColorStops = [
            { stop: 0, rgb: [255, 250, 165] },
            { stop: 0.33, rgb: [253, 197, 110] },
            { stop: 0.66, rgb: [244, 109, 67] },
            { stop: 1, rgb: [180, 23, 44] },
        ];
        const negativeColorStops = [
            { stop: 0, rgb: [194, 230, 255] },
            { stop: 0.33, rgb: [123, 190, 222] },
            { stop: 0.66, rgb: [50, 136, 189] },
            { stop: 1, rgb: [3, 52, 118] },
        ];

        const createStatsTracker = () => ({ min: Infinity, max: -Infinity, count: 0 });
        const resetStatsTracker = (tracker) => {
            tracker.min = Infinity;
            tracker.max = -Infinity;
            tracker.count = 0;
            return tracker;
        };
        const trackStatsValue = (tracker, value) => {
            if (!tracker || !Number.isFinite(value)) return;
            tracker.min = Math.min(tracker.min, value);
            tracker.max = Math.max(tracker.max, value);
            tracker.count += 1;
        };

        const clamp01 = (value) => Math.min(Math.max(value, 0), 1);
        const sampleColorStops = (stops, ratio) => {
            if (!stops.length) return [255, 255, 255];
            const clamped = clamp01(ratio);
            if (clamped <= stops[0].stop) return stops[0].rgb.slice();
            for (let i = 0; i < stops.length - 1; i++) {
                const left = stops[i];
                const right = stops[i + 1];
                if (clamped >= left.stop && clamped <= right.stop) {
                    const span = right.stop - left.stop || 1;
                    const t = (clamped - left.stop) / span;
                    return left.rgb.map((channel, idx) =>
                        Math.round(channel + (right.rgb[idx] - channel) * t)
                    );
                }
            }
            return stops[stops.length - 1].rgb.slice();
        };
        const accentuateRatio = (ratio, intensity) => {
            const safeIntensity = Math.max(intensity, 1);
            return clamp01(Math.pow(clamp01(ratio), 1 / safeIntensity));
        };
        const rgbArrayToCss = (rgb) => `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;

        const clampRatio = (value) => Math.min(Math.max(value, 0), 1);

        const defaultHdrFunction = (input, context = {}) => {
            if (!input) return 0;
            const scale = (context && typeof context.scale === 'number' && Number.isFinite(context.scale))
                ? context.scale
                : 1;
            const base = clamp01(input.ratio ?? 0);
            const shoulder = Math.log1p(base * 8) / Math.log1p(8);
            const gamma = Math.pow(base, 0.75);
            const mix = 0.35;
            let result = (1 - mix) * shoulder + mix * gamma;
            if (scale < 1) {
                result *= Math.min(1.45, Math.pow(1 / Math.max(scale, 0.0001), 0.12));
            }
            return clampRatio(result);
        };

        const defaultColorFunction = (value, stats, range, context = {}) => {
            const safeMax = range.max > 0 ? range.max : 1;
            const safeMin = range.min < 0 ? range.min : -1;
            const scale = (context && typeof context.scale === 'number' && Number.isFinite(context.scale))
                ? context.scale
                : 1;
            const intensity = scale < 1
                ? Math.min(1.6, Math.pow(1 / Math.max(scale, 0.0001), 0.3))
                : 1;

            const applyHDR = (context && typeof context.applyHDR === 'function')
                ? context.applyHDR
                : (input) => defaultHdrFunction(input, { scale });

            if (value >= 0) {
                const hdrRatio = clampRatio(applyHDR({ ratio: value / safeMax, value, stats, range, polarity: 'positive', scale }));
                const ratio = accentuateRatio(hdrRatio, intensity);
                return rgbArrayToCss(sampleColorStops(positiveColorStops, ratio));
            }
            const hdrRatio = clampRatio(applyHDR({ ratio: Math.abs(value / safeMin), value, stats, range, polarity: 'negative', scale }));
            const ratio = accentuateRatio(hdrRatio, intensity);
            return rgbArrayToCss(sampleColorStops(negativeColorStops, ratio));
        };
        let config = { xDistributionScale: 1, backpropStepModes: null };
        let grid = new Map();
        let selectedNodeKey = null;
        let view = { scale: 25, offsetX: 0, offsetY: 50, isDragging: false, lastX: 0, lastY: 0 };
        this.config = config;
        this.grid = grid;
        this.selectedNodeKey = selectedNodeKey;
        this.view = view;
        const aggregationCache = new Map();
        this.aggregationCache = aggregationCache;
        const projection = {
            mode: 'planar',
            rotation: Math.PI / 4,
            tilt: Math.PI / 5,
            scaleZ: 0.6,
        };
        this.projection = projection;
        this.cachedStats = { min: 0, max: 0 };
        this.isComputing = false;
        this.pendingComputePayload = null;
        const workerBridge = GRID_WORKER_SUPPORTED ? new GridWorkerBridge() : null;
        this.workerBridge = workerBridge;
        if (workerBridge && typeof window !== 'undefined') {
            window.addEventListener('beforeunload', () => workerBridge.dispose());
        }

        const MIN_PIXEL_NODE_RADIUS = 3;
        const MIN_PIXEL_EDGE_WIDTH = 0.6;
        const MIN_PIXEL_SELECTION_WIDTH = 1.8;
        const EDGE_RENDER_SCALE_THRESHOLD = 0.9;
        const AGGREGATION_SCALE_THRESHOLD = 6;
        const AGGREGATION_BUCKET_PIXELS = 8;
        const VIEW_CULL_PADDING = 1.5;
        const MIN_VIEW_SCALE = 0.0001;
        const MAX_VIEW_SCALE = 2000;

        function getNodeRadius() {
            return Math.max(0.5, MIN_PIXEL_NODE_RADIUS / Math.max(view.scale, MIN_VIEW_SCALE));
        }

        function getEdgeWidth() {
            return Math.max(0.02, MIN_PIXEL_EDGE_WIDTH / Math.max(view.scale, MIN_VIEW_SCALE));
        }

        function getSelectionWidth() {
            return Math.max(0.12, MIN_PIXEL_SELECTION_WIDTH / Math.max(view.scale, MIN_VIEW_SCALE));
        }

        function getCodeValue(id) {
            if (codeEditors[id]) return codeEditors[id].getValue();
            const field = document.getElementById(id);
            return field ? field.value || '' : '';
        }

        function setCodeValue(id, value) {
            const nextValue = value ?? '';
            if (codeEditors[id]) {
                if (codeEditors[id].getValue() !== nextValue) codeEditors[id].setValue(nextValue);
                return;
            }
            const field = document.getElementById(id);
            if (field) field.value = nextValue;
        }

        function setEditorError(id, hasError) {
            if (codeEditors[id]) {
                const wrapper = codeEditors[id].getWrapperElement();
                if (hasError) {
                    wrapper.classList.add('editor-error');
                    wrapper.style.borderColor = 'var(--error-color)';
                } else {
                    wrapper.classList.remove('editor-error');
                    wrapper.style.borderColor = '';
                }
            } else {
                const field = document.getElementById(id);
                if (field) field.style.borderColor = hasError ? 'var(--error-color)' : '';
            }
        }

        function toggleCustomGradientInputs() {
            customGradientInputs.style.display = controls.gradientMode.value === 'custom' ? 'flex' : 'none';
        }

        function toggleReunificationEditor() {
            if (!reunificationEditorSection) return;
            const isPersonalized = controls.reunification.value === 'personalized';
            reunificationEditorSection.style.display = isPersonalized ? '' : 'none';
            if (isPersonalized) {
                ensureEditorExpanded();
                if (editorGroups.has('reunification')) {
                    setActiveEditor('reunification', 'reunificationLogic');
                    refreshActiveEditors();
                }
            }
        }

        function toggleSpatialEditors() {
            if (!spatialEditorSection) return;
            const mode = controls.projectionMode ? controls.projectionMode.value : 'grid';
            spatialEditorSection.style.display = mode === 'custom' ? '' : 'none';
        }

        function createRootPathMeta() {
            return {
                depth: 0,
                total: 1,
                onesHistogram: { 0: 1 },
                samples: [''],
                sampleComplete: true,
            };
        }

        function clonePathMeta(meta) {
            if (!meta) return null;
            return {
                depth: meta.depth,
                total: meta.total,
                onesHistogram: Object.fromEntries(Object.entries(meta.onesHistogram || {}).map(([key, value]) => [Number(key), value])),
                samples: Array.isArray(meta.samples) ? meta.samples.slice() : [],
                sampleComplete: Boolean(meta.sampleComplete),
            };
        }

        function advancePathMeta(parentMeta, branchIndex) {
            if (!parentMeta || typeof parentMeta !== 'object') return null;
            const nextDepth = parentMeta.depth + 1;
            const onesIncrement = branchIndex === 1 ? 1 : 0;
            const onesHistogram = {};
            Object.entries(parentMeta.onesHistogram || {}).forEach(([key, count]) => {
                const ones = Number(key);
                const nextOnes = ones + onesIncrement;
                onesHistogram[nextOnes] = (onesHistogram[nextOnes] || 0) + count;
            });
            let samples = [];
            let sampleComplete = parentMeta.sampleComplete;
            if (Array.isArray(parentMeta.samples) && parentMeta.samples.length) {
                samples = parentMeta.samples.map(sample => `${sample}${branchIndex === 1 ? '1' : '0'}`);
                if (samples.length > ENUMERATION_SAMPLE_LIMIT) {
                    samples = samples.slice(0, ENUMERATION_SAMPLE_LIMIT);
                    sampleComplete = false;
                }
            }
            return {
                depth: nextDepth,
                total: parentMeta.total,
                onesHistogram,
                samples,
                sampleComplete,
            };
        }

        function mergeUniqueSamples(a = [], b = []) {
            const merged = [...a, ...b];
            const seen = new Set();
            const result = [];
            merged.forEach(sample => {
                if (typeof sample !== 'string') return;
                if (seen.has(sample)) return;
                seen.add(sample);
                result.push(sample);
            });
            return result.sort();
        }

        function mergePathMetas(baseMeta, additionMeta) {
            if (!additionMeta) return baseMeta ? clonePathMeta(baseMeta) : null;
            if (!baseMeta) return clonePathMeta(additionMeta);
            const merged = {
                depth: Math.max(baseMeta.depth, additionMeta.depth),
                total: baseMeta.total + additionMeta.total,
                onesHistogram: {},
                samples: [],
                sampleComplete: false,
            };
            const baseHistogram = baseMeta.onesHistogram || {};
            const additionHistogram = additionMeta.onesHistogram || {};
            Object.entries(baseHistogram).forEach(([key, count]) => {
                const numericKey = Number(key);
                merged.onesHistogram[numericKey] = (merged.onesHistogram[numericKey] || 0) + count;
            });
            Object.entries(additionHistogram).forEach(([key, count]) => {
                const numericKey = Number(key);
                merged.onesHistogram[numericKey] = (merged.onesHistogram[numericKey] || 0) + count;
            });
            const combinedSamples = mergeUniqueSamples(baseMeta.samples || [], additionMeta.samples || []);
            if (combinedSamples.length <= ENUMERATION_SAMPLE_LIMIT && baseMeta.sampleComplete && additionMeta.sampleComplete && merged.total <= ENUMERATION_SAMPLE_LIMIT) {
                merged.samples = combinedSamples;
                merged.sampleComplete = combinedSamples.length === merged.total;
            } else {
                merged.samples = combinedSamples.slice(0, ENUMERATION_SAMPLE_LIMIT);
                merged.sampleComplete = false;
            }
            return merged;
        }

        function computeNodePositionOverride(key, coords, context = {}) {
            if (typeof config.positionFn !== 'function') return null;
            try {
                const safeCoords = {
                    x: Number.isFinite(coords?.x) ? coords.x : 0,
                    y: Number.isFinite(coords?.y) ? coords.y : 0,
                    z: Number.isFinite(coords?.z) ? coords.z : 0,
                };
                const nodeContext = context && context.node ? context.node : null;
                const enrichedContext = {
                    ...(context || {}),
                    key,
                    coords: safeCoords,
                    node: nodeContext,
                };
                const result = config.positionFn(key, safeCoords, nodeContext, enrichedContext);
                if (result && typeof result === 'object') {
                    const x = Number(result.x);
                    const y = Number(result.y);
                    const z = Number(result.z);
                    return {
                        x: Number.isFinite(x) ? x : coords.x,
                        y: Number.isFinite(y) ? y : coords.y,
                        z: Number.isFinite(z) ? z : 0,
                    };
                }
            } catch (error) {
                console.warn('Position logic error', error);
            }
            return null;
        }

        function prepareBinaryInfo(nodeKey) {
            if (!binaryEnumerationSupported) {
                return { supported: false, reason: 'Binary enumeration is available only when two moves are defined.' };
            }
            if (!nodeKey || !grid.has(nodeKey)) {
                return { supported: false, reason: 'Node unavailable for binary analysis.' };
            }
            const node = grid.get(nodeKey);
            if (!node || !node.pathMeta) {
                return { supported: false, reason: 'Binary path metadata not generated for this node.' };
            }
            const meta = node.pathMeta;
            const histogramEntries = Object.entries(meta.onesHistogram || {}).map(([onesKey, count]) => {
                const ones = Number(onesKey);
                const zeros = Math.max(0, meta.depth - ones);
                return { ones, zeros, count };
            }).sort((a, b) => a.ones - b.ones);
            const minOnes = histogramEntries.length ? histogramEntries[0].ones : 0;
            const maxOnes = histogramEntries.length ? histogramEntries[histogramEntries.length - 1].ones : 0;
            const minZeros = histogramEntries.length ? Math.max(0, meta.depth - maxOnes) : meta.depth;
            const maxZeros = histogramEntries.length ? Math.max(0, meta.depth - minOnes) : meta.depth;
            return {
                supported: true,
                nodeKey,
                meta,
                depth: meta.depth,
                totalPaths: meta.total,
                histogramEntries,
                minOnes,
                maxOnes,
                minZeros,
                maxZeros,
                samples: Array.isArray(meta.samples) ? meta.samples : [],
                sampleComplete: Boolean(meta.sampleComplete),
            };
        }

        function updateInspectorBinarySection(nodeKey) {
            if (!inspectorFields.binarySection || !inspectorFields.binaryContent) return;
            if (!nodeKey) {
                inspectorFields.binarySection.classList.add('hidden');
                inspectorFields.binaryContent.textContent = '';
                return;
            }
            const info = prepareBinaryInfo(nodeKey);
            const fragment = document.createDocumentFragment();
            if (!info.supported) {
                inspectorFields.binarySection.classList.remove('hidden');
                const note = document.createElement('div');
                note.className = 'binary-note';
                note.textContent = info.reason;
                fragment.appendChild(note);
                inspectorFields.binaryContent.innerHTML = '';
                inspectorFields.binaryContent.appendChild(fragment);
                return;
            }
            inspectorFields.binarySection.classList.remove('hidden');
            const stats = document.createElement('div');
            stats.className = 'binary-stat';
            stats.innerHTML = `<strong>Total paths:</strong> ${info.totalPaths.toLocaleString()}`;
            fragment.appendChild(stats);

            const depthStat = document.createElement('div');
            depthStat.className = 'binary-stat';
            depthStat.innerHTML = `<strong>Depth:</strong> ${info.depth}`;
            fragment.appendChild(depthStat);

            const ratioStat = document.createElement('div');
            ratioStat.className = 'binary-stat';
            const zerosRange = info.minZeros === info.maxZeros
                ? `${info.minZeros}`
                : `${info.minZeros} – ${info.maxZeros}`;
            const onesRange = info.minOnes === info.maxOnes
                ? `${info.minOnes}`
                : `${info.minOnes} – ${info.maxOnes}`;
            ratioStat.innerHTML = `<strong>0s:</strong> ${zerosRange} &nbsp;•&nbsp; <strong>1s:</strong> ${onesRange}`;
            fragment.appendChild(ratioStat);

            if (info.histogramEntries.length) {
                const distribution = document.createElement('div');
                distribution.className = 'binary-distribution';
                distribution.innerHTML = info.histogramEntries.map(entry => {
                    return `C(${info.depth}, ${entry.ones}) = <strong>${entry.count.toLocaleString()}</strong> (1s=${entry.ones}, 0s=${entry.zeros})`;
                }).join('<br>');
                fragment.appendChild(distribution);
            }

            const binaryFlex = document.createElement('div');
            binaryFlex.className = 'binary-flex';        

            if (info.samples.length) {
                const sampleLabel = document.createElement('div');
                sampleLabel.className = 'binary-stat';
                sampleLabel.innerHTML = '<strong>Enumerations:</strong>';
                binaryFlex.appendChild(sampleLabel);
                const sampleContainer = document.createElement('div');
                sampleContainer.className = 'binary-sample';
                info.samples.forEach(sample => {
                    const code = document.createElement('code');
                    code.textContent = sample || '∅';
                    sampleContainer.appendChild(code);
                });
                binaryFlex.appendChild(sampleContainer);
                if (!info.sampleComplete) {
                    const note = document.createElement('div');
                    note.className = 'binary-note';
                    note.textContent = `Showing ${info.samples.length} of ${info.totalPaths.toLocaleString()} paths.`;
                    binaryFlex.appendChild(note);
                }
            } else if (info.totalPaths > 0) {
                const note = document.createElement('div');
                note.className = 'binary-note';
                note.textContent = 'Enumeration list omitted to maintain performance.';
                binaryFlex.appendChild(note);
            }

            fragment.appendChild(binaryFlex)

            inspectorFields.binaryContent.innerHTML = '';
            inspectorFields.binaryContent.appendChild(fragment);
        }

        function ensureBinaryHoverPopup() {
            if (binaryHoverPopup) return binaryHoverPopup;
            const popup = document.createElement('div');
            popup.id = 'binaryHoverPopup';
            document.body.appendChild(popup);
            binaryHoverPopup = popup;
            app.binaryHoverPopup = binaryHoverPopup;
            return popup;
        }

        function hideBinaryHoverPopup() {
            if (!binaryHoverPopup) return;
            binaryHoverPopup.style.display = 'none';
            binaryHoverPopup.textContent = '';
            currentHoverNodeKey = null;
            app.currentHoverNodeKey = currentHoverNodeKey;
        }

        function showBinaryHoverPopup(nodeKey, position) {
            const popup = ensureBinaryHoverPopup();
            const info = prepareBinaryInfo(nodeKey);
            if (!info.supported) {
                hideBinaryHoverPopup();
                return;
            }
            currentHoverNodeKey = nodeKey;
            app.currentHoverNodeKey = currentHoverNodeKey;
            const lines = [];
            lines.push(`<h5>Node ${nodeKey}</h5>`);
            lines.push(`<div class="binary-stat"><strong>Depth:</strong> ${info.depth}</div>`);
            lines.push(`<div class="binary-stat"><strong>Total paths:</strong> ${info.totalPaths.toLocaleString()}</div>`);
            if (info.histogramEntries.length) {
                const distribution = info.histogramEntries.map(entry => `C(${info.depth}, ${entry.ones}) = <strong>${entry.count.toLocaleString()}</strong> (1s=${entry.ones}, 0s=${entry.zeros})`).join('<br>');
                lines.push(`<div class="binary-distribution">${distribution}</div>`);
            }
            if (info.samples.length) {
                const sampleChips = info.samples.slice(0, 8).map(sample => `<code>${sample || '∅'}</code>`).join(' ');
                lines.push(`<div class="binary-sample">${sampleChips}</div>`);
                if (!info.sampleComplete) {
                    lines.push(`<div class="binary-note">Previewing ${info.samples.length} of ${info.totalPaths.toLocaleString()} paths.</div>`);
                }
            } else if (info.totalPaths > 0) {
                lines.push('<div class="binary-note">Enumeration list omitted to maintain performance.</div>');
            }
            popup.innerHTML = lines.join('');
            popup.style.display = 'block';
            const offsetX = 16;
            const offsetY = 16;
            const posX = Math.min(position.x + offsetX, window.innerWidth - popup.offsetWidth - 12);
            const posY = Math.min(position.y + offsetY, window.innerHeight - popup.offsetHeight - 12);
            popup.style.left = `${Math.max(12, posX)}px`;
            popup.style.top = `${Math.max(12, posY)}px`;
        }

        function getElementAnchorPosition(element) {
            if (!element || !(element instanceof Element)) {
                return { x: 0, y: 0 };
            }
            const rect = element.getBoundingClientRect();
            return { x: rect.right, y: rect.top + rect.height / 2 };
        }

        function handleInspectorHover(event) {
            if (!ENABLE_HOVER_ENUMERATION_POPUP || !binaryEnumerationSupported) return;
            const target = event.target instanceof Element ? event.target.closest('.inspector-node-link') : null;
            if (!target) {
                hideBinaryHoverPopup();
                return;
            }
            const nodeKey = target.dataset.nodeKey;
            if (!nodeKey) return;
            showBinaryHoverPopup(nodeKey, getElementAnchorPosition(target));
        }

        function handleInspectorFocus(event) {
            if (!ENABLE_HOVER_ENUMERATION_POPUP || !binaryEnumerationSupported) return;
            const target = event.target instanceof Element ? event.target.closest('.inspector-node-link') : null;
            if (!target) {
                hideBinaryHoverPopup();
                return;
            }
            const nodeKey = target.dataset.nodeKey;
            if (!nodeKey) return;
            showBinaryHoverPopup(nodeKey, getElementAnchorPosition(target));
        }

        function handleInspectorBlur(event) {
            if (!ENABLE_HOVER_ENUMERATION_POPUP) return;
            const related = event.relatedTarget;
            if (related && inspectorPanel.contains(related)) return;
            hideBinaryHoverPopup();
        }

        function handleCanvasBinaryHover(event) {
            if (!ENABLE_HOVER_ENUMERATION_POPUP || !binaryEnumerationSupported) return;
            if (view.isDragging) {
                hideBinaryHoverPopup();
                return;
            }
            const nodeKey = findNodeAt(event.clientX, event.clientY);
            if (!nodeKey) {
                hideBinaryHoverPopup();
                return;
            }
            showBinaryHoverPopup(nodeKey, { x: event.clientX, y: event.clientY });
        }

        let runHandle = null;
        app.runHandle = runHandle;
        const debouncedRun = new Debouncer(500, () => scheduleRunImmediate());
        app.debouncedRun = debouncedRun;
        function scheduleRunImmediate() {
            debouncedRun.cancel();
            if (runHandle) cancelAnimationFrame(runHandle);
            runHandle = requestAnimationFrame(() => {
                runHandle = null;
                app.runHandle = null;
                run();
            });
            app.runHandle = runHandle;
        }
        function scheduleRunDebounced() {
            debouncedRun.trigger();
        }

        if (window.CodeMirror) {
            const applySizing = (editor) => {
                if (!editor) return;
                editor.setSize(null, '100%');
            };

            const createEditor = (id, control) => {
                if (!control) return null;
                const instance = CodeMirror.fromTextArea(control, {
                    mode: 'javascript',
                    theme: 'darcula',
                    lineNumbers: true,
                    lineWrapping: true,
                    autoCloseBrackets: true,
                    styleActiveLine: true,
                });
                applySizing(instance);
                instance.on('change', (cm, change) => {
                    if ((id === 'backpropLogic' || id === 'backpropFillLogic') && change && change.origin !== 'setValue') {
                        markBackpropPending('code');
                    }
                    scheduleRunDebounced();
                });
                return instance;
            };

            codeEditors.propagationPrimaryLogic = createEditor('propagationPrimaryLogic', controls.propagationPrimary);
            codeEditors.propagationSecondaryLogic = createEditor('propagationSecondaryLogic', controls.propagationSecondary);
            codeEditors.effectiveValueLogic = createEditor('effectiveValueLogic', controls.effectiveValueLogic);
            codeEditors.backpropLogic = createEditor('backpropLogic', controls.backpropLogic);
            codeEditors.backpropFillLogic = createEditor('backpropFillLogic', controls.backpropFillLogic);
            codeEditors.reunificationLogic = createEditor('reunificationLogic', controls.reunificationLogic);
            codeEditors.colorLogic = createEditor('colorLogic', controls.colorLogic);
            codeEditors.hdrLogic = createEditor('hdrLogic', controls.hdrLogic);
            codeEditors.positionLogic = createEditor('positionLogic', controls.positionLogic);
            codeEditors.spaceDistortionLogic = createEditor('spaceDistortionLogic', controls.spaceDistortionLogic);
            refreshActiveEditors();
        } else {
            [
                controls.propagationPrimary,
                controls.propagationSecondary,
                controls.effectiveValueLogic,
                controls.backpropLogic,
                controls.backpropFillLogic,
                controls.reunificationLogic,
                controls.colorLogic,
                controls.hdrLogic,
                controls.positionLogic,
                controls.spaceDistortionLogic,
            ].forEach(control => {
                if (!control) return;
                const isBackprop = control === controls.backpropLogic;
                control.addEventListener('input', (event) => {
                    if (isBackprop && event && event.isTrusted) {
                        markBackpropPending('code');
                    }
                    scheduleRunDebounced();
                });
            });
        }

        function getDimensionDefaults(key) {
            if (!config.dimensionDefaults) return {};
            return config.dimensionDefaults[key] || {};
        }

        function createEmptyDimensionState(key) {
            const defaults = getDimensionDefaults(key);
            return {
                value: Number.isFinite(defaults.value) ? defaults.value : 0,
                isActive: defaults.isActive === true,
                contributors: Number.isFinite(defaults.contributors) ? defaults.contributors : 0,
                meta: [],
            };
        }

        function createInitialDimensions() {
            const dimensions = {};
            if (!Array.isArray(config.propagationDimensions)) return dimensions;
            config.propagationDimensions.forEach(dimension => {
                dimensions[dimension.key] = {
                    value: Number.isFinite(dimension.defaultValue) ? dimension.defaultValue : 0,
                    isActive: dimension.defaultActive === true,
                    contributors: dimension.defaultActive ? 1 : 0,
                    meta: [],
                };
            });
            return dimensions;
        }

        function cloneDimensions(dimensions) {
            if (!dimensions) return {};
            const clone = {};
            Object.entries(dimensions).forEach(([key, payload]) => {
                clone[key] = {
                    value: Number.isFinite(payload?.value) ? payload.value : 0,
                    isActive: Boolean(payload?.isActive),
                    contributors: Number.isFinite(payload?.contributors) ? payload.contributors : 0,
                    meta: Array.isArray(payload?.meta) ? payload.meta.slice() : [],
                };
            });
            return clone;
        }

        function normalizeDimensionResult(raw) {
            if (raw === null || raw === undefined) return null;
            if (typeof raw === 'number') {
                if (!Number.isFinite(raw)) return null;
                return { value: raw, isActive: true, contributors: 1, meta: [] };
            }
            if (typeof raw === 'object') {
                const value = Number.isFinite(raw.value) ? raw.value : 0;
                const isActive = raw.isActive !== false;
                const contributors = Number.isFinite(raw.contributors) ? raw.contributors : 1;
                let meta = [];
                if (raw.meta !== undefined) {
                    meta = Array.isArray(raw.meta) ? raw.meta.slice() : [raw.meta];
                }
                return { value, isActive, contributors, meta };
            }
            return null;
        }

        function createNodeSnapshot(nodeKey, node) {
            if (!node) return null;
            return {
                key: nodeKey,
                value: Number.isFinite(node.value) ? node.value : 0,
                generation: Number.isFinite(node.gen) ? node.gen : 0,
                gen: Number.isFinite(node.gen) ? node.gen : 0,
                parents: Array.isArray(node.parents) ? node.parents.slice() : [],
                children: Array.isArray(node.children) ? node.children.slice() : [],
                dimensions: cloneDimensions(node.dimensions),
                position: node.position && typeof node.position === 'object'
                    ? {
                        x: Number.isFinite(node.position.x) ? node.position.x : 0,
                        y: Number.isFinite(node.position.y) ? node.position.y : 0,
                        z: Number.isFinite(node.position.z) ? node.position.z : 0,
                    }
                    : { x: 0, y: 0, z: 0 },
                pathMeta: node.pathMeta || null,
            };
        }

        function applySpaceDistortion(baseResult, context, rawOutput) {
            if (typeof config.spaceDistortionFn !== 'function') return baseResult;
            try {
                const result = config.spaceDistortionFn(
                    baseResult ? {
                        value: baseResult.value,
                        isActive: baseResult.isActive,
                        contributors: baseResult.contributors,
                        meta: Array.isArray(baseResult.meta) ? baseResult.meta.slice() : [],
                    } : null,
                    {
                        ...context,
                        rawOutput,
                        baseResult: baseResult ? {
                            value: baseResult.value,
                            isActive: baseResult.isActive,
                            contributors: baseResult.contributors,
                            meta: Array.isArray(baseResult.meta) ? baseResult.meta.slice() : [],
                        } : null,
                    }
                );
                if (result === undefined) return baseResult;
                if (result === null) return null;
                if (typeof result === 'number' || typeof result === 'object') {
                    return normalizeDimensionResult(result);
                }
            } catch (error) {
                console.warn('Space distortion logic error', error);
            }
            return baseResult;
        }

        function buildReunificationContext(values) {
            const count = values.length;
            if (!count) {
                return { count: 0, sum: 0, average: 0, min: 0, max: 0 };
            }
            let sum = 0;
            let min = values[0];
            let max = values[0];
            for (let i = 0; i < count; i++) {
                const value = values[i];
                sum += value;
                if (value < min) min = value;
                if (value > max) max = value;
            }
            const average = sum / count;
            return { count, sum, average, min, max };
        }

        function combineValuesByReunification(values, strategy, customFn) {
            if (!values.length) return 0;
            if (strategy === 'personalized') {
                const safeValues = values.slice();
                const context = buildReunificationContext(safeValues);
                if (typeof customFn === 'function') {
                    try {
                        const result = customFn(safeValues, context);
                        if (Number.isFinite(result)) return result;
                    } catch (error) {
                        console.warn('Custom reunification logic error', error);
                    }
                }
                return context.sum;
            }
            switch (strategy) {
                case 'average':
                    return values.reduce((sum, value) => sum + value, 0) / values.length;
                case 'max':
                    return Math.max(...values);
                case 'sum':
                default:
                    return values.reduce((sum, value) => sum + value, 0);
            }
        }

        function mergeIncomingDimensionResults(incoming, reunification, customFn) {
            const aggregates = new Map();
            incoming.forEach(entry => {
                const dimensionResults = entry.dimensions || {};
                Object.entries(dimensionResults).forEach(([key, result]) => {
                    if (!aggregates.has(key)) {
                        aggregates.set(key, { values: [], activeCount: 0, contributors: 0, meta: [] });
                    }
                    const bucket = aggregates.get(key);
                    if (result && Number.isFinite(result.value)) {
                        bucket.values.push(result.value);
                        bucket.contributors += Number.isFinite(result.contributors) ? result.contributors : 1;
                    }
                    if (result && result.isActive) bucket.activeCount += 1;
                    if (result && result.meta) {
                        const meta = Array.isArray(result.meta) ? result.meta : [result.meta];
                        bucket.meta.push(...meta.filter(item => item !== undefined));
                    }
                });
            });
            if (Array.isArray(config.propagationDimensions)) {
                config.propagationDimensions.forEach(dimension => {
                    if (!aggregates.has(dimension.key)) {
                        aggregates.set(dimension.key, { values: [], activeCount: 0, contributors: 0, meta: [] });
                    }
                });
            }
            aggregates.forEach(bucket => {
                bucket.value = combineValuesByReunification(bucket.values, reunification, customFn);
                if (!Number.isFinite(bucket.contributors) || bucket.contributors <= 0) {
                    bucket.contributors = bucket.values.length;
                }
            });
            return aggregates;
        }

        function finalizeDimensionAggregates(aggregates) {
            const result = {};
            aggregates.forEach((bucket, key) => {
                result[key] = {
                    value: Number.isFinite(bucket.value) ? bucket.value : 0,
                    isActive: bucket.activeCount > 0,
                    contributors: Number.isFinite(bucket.contributors) ? bucket.contributors : (bucket.values?.length || 0),
                    meta: Array.isArray(bucket.meta) ? bucket.meta.slice() : [],
                };
            });
            return result;
        }

        function mergeDimensionStates(existing, incoming) {
            const base = cloneDimensions(existing);
            Object.entries(incoming || {}).forEach(([key, addition]) => {
                const current = base[key] || createEmptyDimensionState(key);
                const valueDelta = Number.isFinite(addition?.value) ? addition.value : 0;
                current.value += valueDelta;
                current.isActive = current.isActive || Boolean(addition?.isActive);
                const contributorDelta = Number.isFinite(addition?.contributors) ? addition.contributors : (valueDelta !== 0 ? 1 : 0);
                current.contributors += contributorDelta;
                if (Array.isArray(addition?.meta) && addition.meta.length) {
                    current.meta.push(...addition.meta);
                }
                base[key] = current;
            });
            return base;
        }

        function evaluateEffectiveValue(dimensions, context = {}) {
            const safeDimensions = dimensions || {};
            try {
                if (typeof config.effectiveValueFn === 'function') {
                    const dimensionKeys = Array.isArray(config.propagationDimensions)
                        ? config.propagationDimensions.map(d => d.key)
                        : Object.keys(safeDimensions);
                    const result = config.effectiveValueFn(safeDimensions, { ...context, dimensionKeys });
                    if (Number.isFinite(result)) return result;
                }
            } catch (error) {
                console.warn('Effective value logic error', error);
            }
            const primary = safeDimensions.primary;
            if (primary && Number.isFinite(primary.value)) return primary.value;
            const fallbackKey = Object.keys(safeDimensions)[0];
            if (fallbackKey) {
                const candidate = safeDimensions[fallbackKey];
                if (candidate && Number.isFinite(candidate.value)) return candidate.value;
            }
            return 0;
        }

        function buildBackpropState(nodeKey, node) {
            return {
                key: nodeKey,
                value: Number.isFinite(node.value) ? node.value : 0,
                dimensions: cloneDimensions(node.dimensions || createInitialDimensions()),
                generation: node.gen,
            };
        }

        function accumulateNodeUpdate(container, nodeKey, update) {
            if (!update || typeof update !== 'object') return;
            if (!container.has(nodeKey)) {
                container.set(nodeKey, {
                    valueDelta: 0,
                    valueOverride: null,
                    dimensions: new Map(),
                });
            }
            const entry = container.get(nodeKey);
            if (typeof update.valueOverride === 'number' && Number.isFinite(update.valueOverride)) {
                entry.valueOverride = update.valueOverride;
            } else if (typeof update.valueDelta === 'number' && Number.isFinite(update.valueDelta)) {
                entry.valueDelta += update.valueDelta;
            }
            if (update.dimensions && typeof update.dimensions === 'object') {
                Object.entries(update.dimensions).forEach(([key, delta]) => {
                    const numericDelta = Number(delta);
                    if (!Number.isFinite(numericDelta)) return;
                    entry.dimensions.set(key, (entry.dimensions.get(key) || 0) + numericDelta);
                });
            }
        }

        function applyAccumulatedUpdates(updateMap, step) {
            updateMap.forEach((descriptor, nodeKey) => {
                const node = grid.get(nodeKey);
                if (!node) return;
                if (!node.dimensions) node.dimensions = createInitialDimensions();
                let baseValue = Number.isFinite(node.value) ? node.value : 0;
                const hasDimensionUpdates = descriptor.dimensions.size > 0;
                if (hasDimensionUpdates) {
                    const deltaState = {};
                    descriptor.dimensions.forEach((delta, dimKey) => {
                        deltaState[dimKey] = {
                            value: delta,
                            isActive: Math.abs(delta) > 1e-9,
                            contributors: 1,
                            meta: [],
                        };
                    });
                    node.dimensions = mergeDimensionStates(node.dimensions, deltaState);
                    baseValue = evaluateEffectiveValue(node.dimensions, {
                        key: nodeKey,
                        generation: node.gen,
                        phase: 'backprop',
                        step,
                    });
                }
                if (descriptor.valueOverride !== null && Number.isFinite(descriptor.valueOverride)) {
                    node.value = descriptor.valueOverride;
                } else {
                    const delta = Number.isFinite(descriptor.valueDelta) ? descriptor.valueDelta : 0;
                    const nextValue = baseValue + delta;
                    node.value = Number.isFinite(nextValue) ? nextValue : baseValue;
                }
                if (!Number.isFinite(node.value)) {
                    node.value = 0;
                }
            });
        }

        function applyBackpropagation(steps) {
            if (!Number.isFinite(steps) || steps <= 0 || typeof config.backpropFn !== 'function') return;
            const generationBuckets = new Map();
            grid.forEach((node, key) => {
                if (!generationBuckets.has(node.gen)) generationBuckets.set(node.gen, []);
                generationBuckets.get(node.gen).push([key, node]);
            });
            const generations = Array.from(generationBuckets.keys()).sort((a, b) => b - a);

            for (let step = 0; step < steps; step++) {
                const parentUpdates = new Map();
                const childUpdates = new Map();

                generations.forEach(generation => {
                    const nodes = generationBuckets.get(generation) || [];
                    nodes.forEach(([childKey, childNode]) => {
                        if (!Array.isArray(childNode.parents) || !childNode.parents.length) return;
                        childNode.parents.forEach(parentKey => {
                            const parentNode = grid.get(parentKey);
                            if (!parentNode) return;
                            let result = null;
                            try {
                                const stepMode = Array.isArray(config.backpropStepModes) && config.backpropStepModes.length
                                    ? config.backpropStepModes[step % config.backpropStepModes.length]
                                    : null;
                                result = config.backpropFn(
                                    buildBackpropState(childKey, childNode),
                                    buildBackpropState(parentKey, parentNode),
                                    {
                                        generation,
                                        step,
                                        totalSteps: steps,
                                        childKey,
                                        parentKey,
                                        mode: stepMode,
                                        reverseFill: typeof config.backpropFillFn === 'function' ? config.backpropFillFn : null,
                                    }
                                );
                            } catch (error) {
                                console.warn('Backprop logic error', error);
                            }
                            if (!result) return;
                            if (result.parent) accumulateNodeUpdate(parentUpdates, parentKey, result.parent);
                            if (result.child) accumulateNodeUpdate(childUpdates, childKey, result.child);
                        });
                    });
                });

                applyAccumulatedUpdates(parentUpdates, step);
                applyAccumulatedUpdates(childUpdates, step);
            }
        }

        function generateGridSync() {
            grid.clear();
            selectedNodeKey = null;
            app.selectedNodeKey = selectedNodeKey;
            const startNodeKey = "0,0";
            const rootDimensions = createInitialDimensions();
            const rootValue = evaluateEffectiveValue(rootDimensions, {
                key: startNodeKey,
                generation: 0,
                phase: 'seed',
            });
            const rootBaseCoords = { x: 0, y: 0, z: 0 };
            const rootNode = {
                value: rootValue,
                dimensions: rootDimensions,
                gen: 0,
                parents: [],
                children: [],
                pathMeta: binaryEnumerationSupported ? createRootPathMeta() : null,
                position: rootBaseCoords,
            };
            const rootSnapshot = { ...rootNode, key: startNodeKey };
            const rootPositionOverride = computeNodePositionOverride(startNodeKey, rootBaseCoords, {
                generation: 0,
                phase: 'seed',
                node: rootSnapshot,
            });
            if (rootPositionOverride && typeof rootPositionOverride === 'object') {
                rootNode.position = {
                    x: Number.isFinite(rootPositionOverride.x) ? Number(rootPositionOverride.x) : rootBaseCoords.x,
                    y: Number.isFinite(rootPositionOverride.y) ? Number(rootPositionOverride.y) : rootBaseCoords.y,
                    z: Number.isFinite(rootPositionOverride.z) ? Number(rootPositionOverride.z) : 0,
                };
            }
            grid.set(startNodeKey, rootNode);
            let frontier = new Set([startNodeKey]);

            for (let generationIndex = 0; generationIndex < config.generations; generationIndex++) {
                const nextFrontier = new Set();
                const contributions = new Map();

                frontier.forEach(parentKey => {
                    const parentNode = grid.get(parentKey);
                    if (!parentNode) return;
                    const [x, y] = parentKey.split(',').map(Number);
                    const parentDimensions = cloneDimensions(parentNode.dimensions);

                    config.moves.forEach((move, moveIndex) => {
                        const childX = x + move[0];
                        const childY = y + move[1];
                        const childKey = `${childX},${childY}`;
                        const dimensionResults = {};

                        if (Array.isArray(config.propagationDimensions)) {
                            const parentSnapshot = createNodeSnapshot(parentKey, parentNode);
                            const childCoords = { x: childX, y: childY };
                            config.propagationDimensions.forEach(dimension => {
                                let output = null;
                                try {
                                    output = dimension.fn(
                                        parentNode.value,
                                        parentDimensions,
                                        moveIndex,
                                        move,
                                        {
                                            parentKey,
                                            parentGeneration: parentNode.gen,
                                            moveIndex,
                                            move,
                                            generation: generationIndex,
                                        }
                                    );
                                } catch (error) {
                                    console.warn(`Propagation "${dimension.key}" error`, error);
                                    output = null;
                                }
                                let normalizedResult = normalizeDimensionResult(output);
                                if (normalizedResult || typeof config.spaceDistortionFn === 'function') {
                                    normalizedResult = applySpaceDistortion(normalizedResult, {
                                        parentKey,
                                        parentSnapshot,
                                        childKey,
                                        childCoords,
                                        generation: generationIndex,
                                        moveIndex,
                                        move,
                                        dimensionKey: dimension.key,
                                    }, output);
                                }
                                dimensionResults[dimension.key] = normalizedResult;
                            });
                        }

                        if (!Array.isArray(parentNode.children)) parentNode.children = [];
                        if (!parentNode.children.includes(childKey)) parentNode.children.push(childKey);
                        if (!contributions.has(childKey)) contributions.set(childKey, []);
                        contributions.get(childKey).push({
                            parentKey,
                            moveIndex,
                            dimensions: dimensionResults,
                        });
                    });
                });

                contributions.forEach((incoming, childKey) => {
                    const parentKeys = Array.from(new Set(incoming.map(entry => entry.parentKey)));
                    const aggregates = mergeIncomingDimensionResults(incoming, config.reunification, config.reunificationFn);
                    const childDimensions = finalizeDimensionAggregates(aggregates);
                    const effectiveValue = evaluateEffectiveValue(childDimensions, {
                        key: childKey,
                        parents: parentKeys,
                        generation: generationIndex + 1,
                        phase: 'forward',
                    });

                    let childPathMeta = null;
                    if (binaryEnumerationSupported) {
                        incoming.forEach(entry => {
                            const parentNode = grid.get(entry.parentKey);
                            if (!parentNode || !parentNode.pathMeta) return;
                            const advanced = advancePathMeta(parentNode.pathMeta, entry.moveIndex);
                            if (!advanced) return;
                            childPathMeta = mergePathMetas(childPathMeta, advanced);
                        });
                    }

                    if (grid.has(childKey)) {
                        const childNode = grid.get(childKey);
                        childNode.dimensions = mergeDimensionStates(childNode.dimensions, childDimensions);
                        childNode.value = evaluateEffectiveValue(childNode.dimensions, {
                            key: childKey,
                            parents: parentKeys,
                            generation: generationIndex + 1,
                            phase: 'merge',
                        });
                        if (!Array.isArray(childNode.parents)) childNode.parents = [];
                        parentKeys.forEach(parentKey => {
                            if (!childNode.parents.includes(parentKey)) childNode.parents.push(parentKey);
                        });
                        if (binaryEnumerationSupported && childPathMeta) {
                            childNode.pathMeta = mergePathMetas(childNode.pathMeta, childPathMeta);
                        }
                    } else {
                        const splKey = childKey.split(',');
                        const childX = parseInt(splKey[0]);
                        const childY = parseInt(splKey[1]);
                        const baseCoords = { x: childX, y: childY, z: 0 };
                        const childNode = {
                            value: effectiveValue,
                            dimensions: childDimensions,
                            gen: generationIndex + 1,
                            parents: parentKeys,
                            children: [],
                            pathMeta: binaryEnumerationSupported ? childPathMeta : null,
                            position: baseCoords,
                        };
                        const childSnapshot = { ...childNode, key: childKey };
                        const customPosition = computeNodePositionOverride(childKey, baseCoords, {
                            generation: generationIndex + 1,
                            parents: parentKeys,
                            phase: 'forward',
                            node: childSnapshot,
                        });
                        if (customPosition && typeof customPosition === 'object') {
                            childNode.position = {
                                x: Number.isFinite(customPosition.x) ? Number(customPosition.x) : baseCoords.x,
                                y: Number.isFinite(customPosition.y) ? Number(customPosition.y) : baseCoords.y,
                                z: Number.isFinite(customPosition.z) ? Number(customPosition.z) : 0,
                            };
                        }
                        grid.set(childKey, childNode);
                    }

                    nextFrontier.add(childKey);
                });

                frontier = nextFrontier;
            }

            if (config.backpropSteps > 0 && typeof config.backpropFn === 'function') {
                applyBackpropagation(config.backpropSteps);
            }

            app.cachedStats = computeGridStats(true);
            resetViewCaches();
        }

        function applyGridPayload(payload) {
            grid.clear();
            selectedNodeKey = null;
            app.selectedNodeKey = selectedNodeKey;

            if (!payload || !Array.isArray(payload.nodes)) {
                binaryEnumerationSupported = Boolean(payload?.binaryEnumerationSupported);
                app.binaryEnumerationSupported = binaryEnumerationSupported;
                config.binaryEnumerationSupported = binaryEnumerationSupported;
                app.cachedStats = { min: 0, max: 0 };
                resetViewCaches();
                return;
            }

            payload.nodes.forEach((record) => {
                if (!record || typeof record.key !== 'string') return;
                const positionSource = (record.position && typeof record.position === 'object')
                    ? {
                        x: Number.isFinite(record.position.x) ? record.position.x : Number(record.position.x) || 0,
                        y: Number.isFinite(record.position.y) ? record.position.y : Number(record.position.y) || 0,
                        z: Number.isFinite(record.position.z) ? record.position.z : Number(record.position.z) || 0,
                    }
                    : null;
                const fallbackPosition = (() => {
                    const [px, py] = record.key.split(',').map(Number);
                    return { x: Number.isFinite(px) ? px : 0, y: Number.isFinite(py) ? py : 0, z: 0 };
                })();
                grid.set(record.key, {
                    value: Number.isFinite(record.value) ? record.value : 0,
                    dimensions: record.dimensions && typeof record.dimensions === 'object' ? record.dimensions : {},
                    gen: Number.isFinite(record.gen) ? record.gen : 0,
                    parents: Array.isArray(record.parents) ? record.parents.slice() : [],
                    children: Array.isArray(record.children) ? record.children.slice() : [],
                    pathMeta: record.pathMeta || null,
                    position: positionSource || fallbackPosition,
                });
            });

            binaryEnumerationSupported = Boolean(payload.binaryEnumerationSupported);
            app.binaryEnumerationSupported = binaryEnumerationSupported;
            config.binaryEnumerationSupported = binaryEnumerationSupported;

            if (payload.stats && Number.isFinite(payload.stats.min) && Number.isFinite(payload.stats.max)) {
                app.cachedStats = { min: payload.stats.min, max: payload.stats.max };
            } else {
                app.cachedStats = computeGridStats(true);
            }
            resetViewCaches();
        }

        function resetViewCaches() {
            aggregationCache.clear();
        }

        function setPositionLogic(source, options = {}) {
            const autoRun = options.autoRun !== false;
            const nextSource = typeof source === 'string' ? source : '';
            let compiled = null;
            if (nextSource) {
                try {
                    compiled = new Function('key', 'coords', 'node', 'context', `return (() => { ${nextSource} })();`);
                    const sampleNode = {
                        key: '0,0',
                        value: 0,
                        gen: 0,
                        parents: [],
                        children: [],
                        dimensions: {},
                        position: { x: 0, y: 0, z: 0 },
                    };
                    const probe = compiled('0,0', { x: 0, y: 0, z: 0 }, sampleNode, { generation: 0, phase: 'probe', node: sampleNode });
                    if (probe && typeof probe === 'object') {
                        if ((probe.x !== undefined && !Number.isFinite(Number(probe.x)))
                            || (probe.y !== undefined && !Number.isFinite(Number(probe.y)))
                            || (probe.z !== undefined && !Number.isFinite(Number(probe.z)))) {
                            throw new Error('Position logic must return finite coordinates.');
                        }
                    }
                } catch (error) {
                    console.warn('Failed to compile position logic', error);
                    return false;
                }
            }

            config.positionSource = nextSource;
            config.positionFn = nextSource && nextSource.trim() ? compiled : null;
            if (controls.projectionMode && nextSource && nextSource.trim()) {
                controls.projectionMode.value = 'custom';
                toggleSpatialEditors();
            }
            if (nextSource && nextSource.trim()) {
                config.projectionMode = 'custom';
            }
            setCodeValue('positionLogic', nextSource);
            if (config.workerPayload) {
                config.workerPayload.positionSource = config.projectionMode === 'custom' ? nextSource : '';
            }
            resetViewCaches();
            if (autoRun) {
                scheduleRunImmediate();
            }
            return true;
        }

        function setProjectionMode(mode, overrides = {}) {
            const normalized = typeof mode === 'string' ? mode.toLowerCase() : 'planar';
            if (normalized === 'planar' || normalized === 'isometric') {
                projection.mode = normalized;
            }
            if (overrides && typeof overrides === 'object') {
                if (Number.isFinite(overrides.rotation)) {
                    projection.rotation = overrides.rotation;
                }
                if (Number.isFinite(overrides.tilt)) {
                    projection.tilt = overrides.tilt;
                }
                if (Number.isFinite(overrides.scaleZ)) {
                    projection.scaleZ = overrides.scaleZ;
                }
            }
            resetViewCaches();
            drawGrid();
            return projection.mode;
        }

        function resolvePositionFromKey(key) {
            const [rawX, rawY] = typeof key === 'string' ? key.split(',').map(Number) : [0, 0];
            const x = Number.isFinite(rawX) ? rawX : 0;
            const y = Number.isFinite(rawY) ? rawY : 0;
            return { x, y, z: 0 };
        }

        function getNodePosition(node, key) {
            if (node && node.position && Number.isFinite(node.position.x) && Number.isFinite(node.position.y)) {
                const z = Number.isFinite(node.position.z) ? node.position.z : 0;
                return { x: node.position.x, y: node.position.y, z };
            }
            return resolvePositionFromKey(key);
        }

        function projectPosition(position) {
            if (!position) return { x: 0, y: 0, depth: 0 };
            const mode = projection.mode;

            ///
            /// Everything about scaleX
            ///
            const viewScale = Number.isFinite(view.scale) ? view.scale : 1;
            let scaleX = Number.isFinite(config.xDistributionScale) ? config.xDistributionScale : 1;
            scaleX = Math.pow(scaleX, 3);

            if (viewScale !== 1) {
                // Exponentially adjust the effective X scale with zoom while clamping to a safe positive range.
                const safeViewScale = Math.max(viewScale, MIN_VIEW_SCALE);
                const distributionRatio = Math.max(Math.abs(config.xDistributionScale), 1e-4);
                const exponent = Math.log2(distributionRatio);
                const exponentialScale = scaleX / Math.pow(safeViewScale, exponent);
                const minScale = MIN_VIEW_SCALE;
                const maxScale = 1e6;
                scaleX = clampNumber(exponentialScale, minScale, maxScale);
            }

            ///
            ///

            const baseX = Number.isFinite(position.x) ? position.x * scaleX : 0;
            const baseY = Number.isFinite(position.y) ? position.y : 0;
            const baseZ = Number.isFinite(position.z) ? position.z : 0;
            if (mode === 'isometric') {
                const rotation = Number.isFinite(projection.rotation) ? projection.rotation : Math.PI / 4;
                const tilt = Number.isFinite(projection.tilt) ? projection.tilt : Math.PI / 5;
                const scaleZ = Number.isFinite(projection.scaleZ) ? projection.scaleZ : 0.6;
                const cosRot = Math.cos(rotation);
                const sinRot = Math.sin(rotation);
                const rotatedX = baseX * cosRot - baseY * sinRot;
                const rotatedY = baseX * sinRot + baseY * cosRot;
                const cosTilt = Math.cos(tilt);
                const sinTilt = Math.sin(tilt);
                const adjustedZ = baseZ * scaleZ;
                const projX = rotatedX;
                const projY = rotatedY * cosTilt - adjustedZ * sinTilt;
                const depth = rotatedY * sinTilt + adjustedZ * cosTilt;
                return { x: projX, y: projY, depth };
            }
            return { x: baseX, y: baseY, depth: baseZ };
        }

        function getNodeRenderPosition(node, key) {
            const position = getNodePosition(node, key);
            return projectPosition(position);
        }

        function getAggregationCacheKey(bucketWorldSize) {
            if (!Number.isFinite(bucketWorldSize) || bucketWorldSize <= 0) return 'default';
            return bucketWorldSize.toFixed(3);
        }

        function ensureAggregationCacheEntry(cacheKey, bucketWorldSize) {
            if (aggregationCache.has(cacheKey)) return aggregationCache.get(cacheKey);
            const safeBucketSize = Number.isFinite(bucketWorldSize) && bucketWorldSize > 0 ? bucketWorldSize : 1;
            const buckets = new Map();
            grid.forEach((node, key) => {
                const { x, y } = getNodeRenderPosition(node, key);
                const bucketX = Math.round(x / safeBucketSize);
                const bucketY = Math.round(y / safeBucketSize);
                const bucketKey = `${bucketX},${bucketY}`;
                let bucket = buckets.get(bucketKey);
                if (!bucket) {
                    bucket = {
                        key: bucketKey,
                        xSum: 0,
                        ySum: 0,
                        valueSum: 0,
                        count: 0,
                        maxValue: -Infinity,
                        minValue: Infinity,
                        minX: Infinity,
                        maxX: -Infinity,
                        minY: Infinity,
                        maxY: -Infinity,
                    };
                    buckets.set(bucketKey, bucket);
                }
                bucket.xSum += x;
                bucket.ySum += y;
                bucket.valueSum += Number.isFinite(node.value) ? node.value : 0;
                bucket.count += 1;
                bucket.maxValue = Math.max(bucket.maxValue, node.value);
                bucket.minValue = Math.min(bucket.minValue, node.value);
                bucket.minX = Math.min(bucket.minX, x);
                bucket.maxX = Math.max(bucket.maxX, x);
                bucket.minY = Math.min(bucket.minY, y);
                bucket.maxY = Math.max(bucket.maxY, y);
            });
            const entry = { bucketWorldSize: safeBucketSize, buckets };
            aggregationCache.set(cacheKey, entry);
            if (aggregationCache.size > 24) {
                const oldestKey = aggregationCache.keys().next().value;
                if (oldestKey !== undefined && oldestKey !== cacheKey) {
                    aggregationCache.delete(oldestKey);
                }
            }
            return entry;
        }

        function drawGrid() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2 + view.offsetX, canvas.height / 2 + view.offsetY);
            const safeViewScale = clampNumber(
                Number.isFinite(view.scale) ? view.scale : MIN_VIEW_SCALE,
                MIN_VIEW_SCALE,
                MAX_VIEW_SCALE
            );
            if (safeViewScale !== view.scale) {
                view.scale = safeViewScale;
            }
            ctx.scale(safeViewScale, safeViewScale);

            const stats = computeGridStats();
            const nodeRadius = getNodeRadius();
            const selectionWidth = getSelectionWidth();
            const edgeWidth = getEdgeWidth();
            const safeScale = Math.max(safeViewScale, MIN_VIEW_SCALE);

            const hdrContext = { scale: view.scale };
            const applyHDR = (input) => {
                try {
                    if (config.hdrFn) {
                        const result = config.hdrFn(input, hdrContext);
                        if (Number.isFinite(result)) return clampRatio(result);
                    }
                } catch (error) {
                    console.warn('HDR logic error', error);
                }
                return defaultHdrFunction(input, hdrContext);
            };
            const colorContext = { scale: view.scale, applyHDR, clusterSize: 1, visibleStats: null, gradientRange: null };

            const padding = nodeRadius + VIEW_CULL_PADDING;
            const halfWidth = canvas.width / 2;
            const halfHeight = canvas.height / 2;
            const viewport = {
                minX: (-halfWidth - view.offsetX) / safeScale - padding,
                maxX: (halfWidth - view.offsetX) / safeScale + padding,
                minY: (-halfHeight - view.offsetY) / safeScale - padding,
                maxY: (halfHeight - view.offsetY) / safeScale + padding,
            };

            const shouldAggregate = view.scale < AGGREGATION_SCALE_THRESHOLD;
            const renderEdges = !shouldAggregate && view.scale >= EDGE_RENDER_SCALE_THRESHOLD;
            const visibleNodes = new Map();
            const valueStatsTracker = createStatsTracker();
            const renderStatsTracker = createStatsTracker();
            let visibleBuckets = null;
            let bucketWorldSize = 0;

            if (shouldAggregate) {
                bucketWorldSize = Math.max(AGGREGATION_BUCKET_PIXELS / safeScale, nodeRadius * 2);
                const cacheKey = getAggregationCacheKey(bucketWorldSize);
                const cacheEntry = ensureAggregationCacheEntry(cacheKey, bucketWorldSize);
                const buckets = cacheEntry?.buckets || new Map();
                visibleBuckets = [];

                let nodeMaxX = Infinity * -1;
                buckets.forEach((bucket) => {
                    if (!bucket || !bucket.count) return;

                    if(bucket.maxX > nodeMaxX) nodeMaxX = bucket.maxX;

                    if (bucket.maxX < viewport.minX || bucket.minX > viewport.maxX || bucket.maxY < viewport.minY || bucket.minY > viewport.maxY) {
                        return;
                    }
                    visibleBuckets.push(bucket);
                    trackStatsValue(valueStatsTracker, bucket.maxValue);
                    trackStatsValue(valueStatsTracker, bucket.minValue);
                });

                view.nodeMaxX = nodeMaxX; //todo: sync it
            } else {
                let nodeMaxX = Infinity * -1;
                for (const [key, node] of grid.entries()) {
                    const projected = getNodeRenderPosition(node, key);
                    const { x, y, depth } = projected;

                    if(x > nodeMaxX) nodeMaxX = x;

                    if (x < viewport.minX || x > viewport.maxX || y < viewport.minY || y > viewport.maxY) continue;

                    visibleNodes.set(key, { node, x, y, depth });
                    trackStatsValue(valueStatsTracker, node.value);
                    trackStatsValue(renderStatsTracker, node.value);
                }

                view.nodeMaxX = nodeMaxX;
            }

            if (renderEdges && visibleNodes.size) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
                ctx.lineWidth = edgeWidth;
                for (const [key, entry] of visibleNodes.entries()) {
                    const { node, x: x1, y: y1 } = entry;
                    for (const parentKey of node.parents) {
                        const parent = visibleNodes.get(parentKey);
                        if (!parent) continue;
                        ctx.beginPath();
                        ctx.moveTo(parent.x, parent.y);
                        ctx.lineTo(x1, y1);
                        ctx.stroke();
                    }
                }
            }

            let visibleStatsForRange = renderStatsTracker.count ? renderStatsTracker : valueStatsTracker;
            let gradientRange = resolveGradientRange(stats, visibleStatsForRange, view);
            colorContext.visibleStats = visibleStatsForRange;
            colorContext.gradientRange = gradientRange;

            if (shouldAggregate) {
                resetStatsTracker(renderStatsTracker);
                if (Array.isArray(visibleBuckets)) {
                    visibleBuckets.forEach((bucket) => {
                        if (!bucket.count) return;
                        const averageValue = bucket.valueSum / bucket.count;
                        const strongestAbs = Math.abs(bucket.maxValue) >= Math.abs(bucket.minValue) ? bucket.maxValue : bucket.minValue;
                        const blend = Math.min(0.7, bucket.count / 12);
                        const displayValue = averageValue * (1 - blend) + strongestAbs * blend;
                        bucket.displayValue = displayValue;
                        trackStatsValue(renderStatsTracker, displayValue);
                    });
                }
                visibleStatsForRange = renderStatsTracker.count ? renderStatsTracker : valueStatsTracker;
                gradientRange = resolveGradientRange(stats, visibleStatsForRange, view);
                colorContext.visibleStats = visibleStatsForRange;
                colorContext.gradientRange = gradientRange;

                if (Array.isArray(visibleBuckets)) {
                    visibleBuckets.forEach((bucket) => {
                        if (!bucket.count) return;
                        const avgX = bucket.xSum / bucket.count;
                        const avgY = bucket.ySum / bucket.count;
                        const sizeBoost = Math.min(3, Math.sqrt(bucket.count));
                        const adjustedRadius = Math.max(nodeRadius, nodeRadius * sizeBoost);
                        colorContext.clusterSize = bucket.count;
                        const displayValue = bucket.displayValue ?? (bucket.valueSum / bucket.count);
                        ctx.fillStyle = getNodeColor(displayValue, stats, gradientRange, colorContext);
                        ctx.beginPath();
                        ctx.arc(avgX, avgY, adjustedRadius, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }

                if (selectedNodeKey && grid.has(selectedNodeKey)) {
                    const node = grid.get(selectedNodeKey);
                    const { x: sx, y: sy } = getNodeRenderPosition(node, selectedNodeKey);
                    if (sx >= viewport.minX && sx <= viewport.maxX && sy >= viewport.minY && sy <= viewport.maxY) {
                        colorContext.clusterSize = 1;
                        ctx.fillStyle = getNodeColor(node.value, stats, gradientRange, colorContext);
                        ctx.beginPath();
                        ctx.arc(sx, sy, Math.max(nodeRadius, nodeRadius * 1.25), 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = selectionWidth;
                        ctx.stroke();
                    }
                }
            } else {
                colorContext.clusterSize = 1;
                const iterable = projection.mode === 'isometric'
                    ? Array.from(visibleNodes.entries()).sort((a, b) => {
                        const depthA = Number.isFinite(a[1].depth) ? a[1].depth : 0;
                        const depthB = Number.isFinite(b[1].depth) ? b[1].depth : 0;
                        return depthA - depthB;
                    })
                    : visibleNodes.entries();
                for (const [key, entry] of iterable) {
                    const { node, x, y } = entry;
                    ctx.fillStyle = getNodeColor(node.value, stats, gradientRange, colorContext);
                    ctx.beginPath();
                    ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
                    ctx.fill();
                    if (key === selectedNodeKey) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = selectionWidth;
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();

            if (app.isComputing) {
                ctx.save();
                ctx.fillStyle = 'rgba(26, 26, 29, 0.55)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f0f0f0';
                ctx.font = '16px "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Computing grid...', canvas.width / 2, canvas.height / 2);
                ctx.restore();
            }
        }

        function computeGridStats(forceRecompute = false) {
            if (!forceRecompute && app.cachedStats && Number.isFinite(app.cachedStats.min) && Number.isFinite(app.cachedStats.max)) {
                return app.cachedStats;
            }
            let min = Infinity;
            let max = -Infinity;
            for (const node of grid.values()) {
                min = Math.min(min, node.value);
                max = Math.max(max, node.value);
            }
            if (!grid.size) {
                min = 0;
                max = 0;
            }
            const stats = { min, max };
            app.cachedStats = stats;
            return stats;
        }

        function resolveGradientRange(globalStats, viewStats, viewState) {
            const fallbackMin = (globalStats && Number.isFinite(globalStats.min)) ? globalStats.min : 0;
            const fallbackMax = (globalStats && Number.isFinite(globalStats.max)) ? globalStats.max : 0;
            const hasViewSamples = viewStats && Number.isFinite(viewStats.min) && Number.isFinite(viewStats.max) && viewStats.count > 0;

            let blend = 0;
            if (hasViewSamples) {
                const countFactor = clampNumber(viewStats.count / 40, 0, 1);
                const scaleFactor = (viewState && Number.isFinite(viewState.scale))
                    ? clampNumber(Math.log10(viewState.scale + 1) / 1.6, 0, 1)
                    : 0.2;
                blend = clampNumber(0.2 + countFactor * 0.6 + scaleFactor * 0.2, 0, 1);
            }

            const mixValue = (viewValue, fallbackValue) => {
                if (!hasViewSamples) return fallbackValue;
                return viewValue * blend + fallbackValue * (1 - blend);
            };

            const padRange = (minValue, maxValue) => {
                if (minValue === maxValue) {
                    const padding = Math.max(Math.abs(minValue) * 0.25, 0.5);
                    return { min: minValue - padding, max: maxValue + padding };
                }
                const span = maxValue - minValue;
                const padding = span * 0.08 || 0.5;
                return { min: minValue - padding, max: maxValue + padding };
            };

            switch (config.gradientMode) {
                case 'positive': {
                    const viewMax = hasViewSamples ? Math.max(0, viewStats.max) : 0;
                    const fallbackPositive = fallbackMax > 0 ? fallbackMax : 1;
                    const resolvedMax = mixValue(Math.max(viewMax, 0), Math.max(fallbackPositive, 1));
                    return padRange(0, resolvedMax);
                }
                case 'negative': {
                    const viewMin = hasViewSamples ? Math.min(0, viewStats.min) : 0;
                    const fallbackNegative = fallbackMin < 0 ? fallbackMin : -1;
                    const resolvedMin = mixValue(Math.min(viewMin, 0), Math.min(fallbackNegative, -1));
                    return padRange(resolvedMin, 0);
                }
                case 'custom': {
                    if (!config.gradientCustom) return padRange(-1, 1);
                    let { min, max } = config.gradientCustom;
                    if (!Number.isFinite(min) || !Number.isFinite(max)) {
                        min = fallbackMin;
                        max = fallbackMax;
                    }
                    if (min === max) {
                        return padRange(min, max);
                    }
                    return { min, max };
                }
                case 'symmetric':
                default: {
                    const globalAbs = Math.max(Math.abs(fallbackMin), Math.abs(fallbackMax), 1);
                    const viewAbs = hasViewSamples
                        ? Math.max(Math.abs(viewStats.min), Math.abs(viewStats.max), 0)
                        : globalAbs;
                    const resolvedAbs = mixValue(viewAbs, globalAbs);
                    return padRange(-resolvedAbs, resolvedAbs);
                }
            }
        }

        function getNodeColor(value, stats, range, context) {
            try {
                const result = config.colorFn(value, stats, range, context);
                if (typeof result === 'string') return result;
            } catch (error) {
                console.warn('Color logic error', error);
            }
            return defaultColorFunction(value, stats, range, context);
        }

        function updateConfigFromUI() {
            controls.generations.style.borderColor = '';
            controls.moves.style.borderColor = '';
            controls.gradientMin.style.borderColor = '';
            controls.gradientMax.style.borderColor = '';
            controls.backpropSteps.style.borderColor = '';
            setEditorError('propagationPrimaryLogic', false);
            setEditorError('propagationSecondaryLogic', false);
            setEditorError('effectiveValueLogic', false);
            setEditorError('backpropLogic', false);
            setEditorError('backpropFillLogic', false);
            setEditorError('reunificationLogic', false);
            setEditorError('colorLogic', false);
            setEditorError('hdrLogic', false);
            setEditorError('positionLogic', false);
            setEditorError('spaceDistortionLogic', false);

            const generations = parseInt(controls.generations.value, 10);
            if (!Number.isFinite(generations) || generations < 1) {
                controls.generations.style.borderColor = 'var(--error-color)';
                return false;
            }

            let backpropSteps = parseInt(controls.backpropSteps.value, 10);
            if (!Number.isFinite(backpropSteps) || backpropSteps < 0) {
                controls.backpropSteps.style.borderColor = 'var(--error-color)';
                return false;
            }
            backpropSteps = Math.min(Math.round(backpropSteps), 999);
            controls.backpropSteps.value = backpropSteps;

            let moves;
            try {
                moves = JSON.parse(controls.moves.value);
            } catch (error) {
                controls.moves.style.borderColor = 'var(--error-color)';
                return false;
            }
            if (!Array.isArray(moves)) {
                controls.moves.style.borderColor = 'var(--error-color)';
                return false;
            }

            const sampleDimensions = {
                primary: { value: 1, isActive: true, contributors: 1, meta: [] },
                secondary: { value: 0, isActive: false, contributors: 0, meta: [] },
            };

            const dimensionDefinitions = [
                { key: 'primary', id: 'propagationPrimaryLogic', defaultValue: 1, defaultActive: true },
                { key: 'secondary', id: 'propagationSecondaryLogic', defaultValue: 0, defaultActive: false },
            ];

            const propagationDimensions = [];
            const propagationSources = {};
            const dimensionDefaults = {};

            for (const def of dimensionDefinitions) {
                const source = getCodeValue(def.id);
                let fn;
                try {
                    fn = new Function('parentValue', 'parentDimensions', 'index', 'move', 'context', `return (() => { ${source} })();`);
                    fn(
                        1,
                        sampleDimensions,
                        0,
                        Array.isArray(moves[0]) ? moves[0] : [0, 0],
                        { generation: 0, moveIndex: 0 }
                    );
                } catch (error) {
                    setEditorError(def.id, true);
                    return false;
                }
                propagationDimensions.push({
                    key: def.key,
                    source,
                    fn,
                    defaultValue: def.defaultValue,
                    defaultActive: def.defaultActive,
                });
                propagationSources[def.key] = source;
                dimensionDefaults[def.key] = {
                    value: def.defaultValue,
                    isActive: def.defaultActive,
                    contributors: def.defaultActive ? 1 : 0,
                };
            }

            const gradientMode = controls.gradientMode.value;
            let gradientCustom = null;
            if (gradientMode === 'custom') {
                const minVal = parseFloat(controls.gradientMin.value);
                const maxVal = parseFloat(controls.gradientMax.value);
                if (!Number.isFinite(minVal) || !Number.isFinite(maxVal) || minVal >= maxVal) {
                    controls.gradientMin.style.borderColor = 'var(--error-color)';
                    controls.gradientMax.style.borderColor = 'var(--error-color)';
                    return false;
                }
                gradientCustom = { min: minVal, max: maxVal };
            }

            let xDistributionScale = 1;
            if (controls.xDistributionScale) {
                const raw = parseFloat(controls.xDistributionScale.value);
                xDistributionScale = Number.isFinite(raw) ? clampNumber(raw, 0.05, 3) : 1;
                controls.xDistributionScale.value = xDistributionScale;
                updateXDistributionLabel(xDistributionScale);
            }

            const colorLogicSource = getCodeValue('colorLogic');
            let colorFn;
            try {
                colorFn = new Function('value', 'stats', 'range', 'context', `return (() => { ${colorLogicSource} })();`);
                const hdrPreview = (input) => defaultHdrFunction(input, { scale: view.scale });
                const colorTest = colorFn(0, { min: 0, max: 0 }, { min: 0, max: 1 }, { scale: view.scale, applyHDR: hdrPreview });
                if (typeof colorTest !== 'string') throw new Error('Color logic must return a CSS string.');
            } catch (error) {
                setEditorError('colorLogic', true);
                return false;
            }

            const hdrLogicSource = getCodeValue('hdrLogic');
            let hdrFn;
            try {
                hdrFn = new Function('input', 'context', `return (() => { ${hdrLogicSource} })();`);
                const hdrTest = hdrFn(
                    { ratio: 0.5, value: 0.5, stats: { min: 0, max: 1 }, range: { min: -1, max: 1 }, polarity: 'positive', scale: view.scale },
                    { scale: view.scale }
                );
                if (!Number.isFinite(hdrTest)) throw new Error('HDR logic must return a finite number.');
            } catch (error) {
                setEditorError('hdrLogic', true);
                return false;
            }

            const effectiveValueSource = getCodeValue('effectiveValueLogic');
            let effectiveValueFn;
            try {
                effectiveValueFn = new Function('dimensions', 'context', `return (() => { ${effectiveValueSource} })();`);
                const effectiveTest = effectiveValueFn(sampleDimensions, { phase: 'validation', dimensionKeys: ['primary', 'secondary'] });
                if (!Number.isFinite(effectiveTest)) throw new Error('Effective value logic must return a finite number.');
            } catch (error) {
                setEditorError('effectiveValueLogic', true);
                return false;
            }

            const backpropSource = getCodeValue('backpropLogic');
            const sampleChildState = { key: 'child', value: 1, dimensions: sampleDimensions, generation: 1 };
            const sampleParentState = { key: 'parent', value: 0.5, dimensions: sampleDimensions, generation: 0 };
            const sampleBackpropContext = {
                generation: 1,
                step: 0,
                totalSteps: Math.max(backpropSteps, 1),
                childKey: 'child',
                parentKey: 'parent',
            };
            let backpropFn;
            try {
                backpropFn = new Function('childState', 'parentState', 'context', `return (() => { ${backpropSource} })();`);
                const sampleResult = backpropFn(
                    sampleChildState,
                    sampleParentState,
                    sampleBackpropContext
                );
                if (sampleResult !== null && sampleResult !== undefined && typeof sampleResult !== 'object') {
                    throw new Error('Backpropagation function must return an object or null.');
                }
            } catch (error) {
                setEditorError('backpropLogic', true);
                return false;
            }

            const backpropFillSource = getCodeValue('backpropFillLogic');
            let backpropFillFn = null;
            try {
                backpropFillFn = new Function('childState', 'parentState', 'context', `return (() => { ${backpropFillSource} })();`);
                const fillResult = backpropFillFn(
                    sampleChildState,
                    sampleParentState,
                    sampleBackpropContext
                );
                if (fillResult !== null && fillResult !== undefined && typeof fillResult !== 'object') {
                    throw new Error('Backprop fill helper must return an object or null.');
                }
            } catch (error) {
                setEditorError('backpropFillLogic', true);
                return false;
            }

            const reunificationMode = controls.reunification.value;
            const reunificationSource = getCodeValue('reunificationLogic');
            let reunificationFn = null;
            if (reunificationMode === 'personalized') {
                try {
                    reunificationFn = new Function('values', 'context', `return (() => { ${reunificationSource} })();`);
                    const sampleValues = [1, -0.5, 0.25];
                    const sampleResult = reunificationFn(sampleValues.slice(), buildReunificationContext(sampleValues));
                    if (!Number.isFinite(sampleResult)) throw new Error('Custom reunification must return a finite number.');
                } catch (error) {
                    setEditorError('reunificationLogic', true);
                    return false;
                }
            }

            binaryEnumerationSupported = Array.isArray(moves) && moves.length === 2;
            app.binaryEnumerationSupported = binaryEnumerationSupported;

            const sampleNodeDimensions = {};
            propagationDimensions.forEach(dimension => {
                sampleNodeDimensions[dimension.key] = {
                    value: dimension.defaultValue,
                    isActive: dimension.defaultActive,
                    contributors: dimension.defaultActive ? 1 : 0,
                    meta: [],
                };
            });
            const projectionMode = controls.projectionMode ? controls.projectionMode.value : 'grid';
            const positionSourceRaw = getCodeValue('positionLogic');
            const spaceDistortionSourceRaw = getCodeValue('spaceDistortionLogic');
            let positionFn = null;
            let spaceDistortionFn = null;
            let workerPositionSource = '';
            let workerSpaceDistortionSource = '';

            if (projectionMode === 'custom') {
                if (positionSourceRaw && positionSourceRaw.trim()) {
                    try {
                        positionFn = new Function('key', 'coords', 'node', 'context', `return (() => { ${positionSourceRaw} })();`);
                        const sampleNode = {
                            key: '0,0',
                            value: 0,
                            gen: 0,
                            parents: [],
                            children: [],
                            dimensions: sampleNodeDimensions,
                            position: { x: 0, y: 0, z: 0 },
                        };
                        const probe = positionFn(
                            '0,0',
                            { x: 0, y: 0, z: 0 },
                            sampleNode,
                            { generation: 0, phase: 'probe', node: sampleNode }
                        );
                        if (probe && typeof probe === 'object') {
                            if ((probe.x !== undefined && !Number.isFinite(Number(probe.x)))
                                || (probe.y !== undefined && !Number.isFinite(Number(probe.y)))
                                || (probe.z !== undefined && !Number.isFinite(Number(probe.z)))) {
                                throw new Error('Position logic must return finite coordinates.');
                            }
                        }
                    } catch (error) {
                        setEditorError('positionLogic', true);
                        return false;
                    }
                }

                if (spaceDistortionSourceRaw && spaceDistortionSourceRaw.trim()) {
                    try {
                        spaceDistortionFn = new Function('baseResult', 'context', `return (() => { ${spaceDistortionSourceRaw} })();`);
                        const sampleContext = {
                            parentKey: '0,0',
                            parentSnapshot: {
                                key: '0,0',
                                value: 1,
                                generation: 0,
                                position: { x: 0, y: 0, z: 0 },
                                dimensions: sampleNodeDimensions,
                            },
                            childKey: '1,0',
                            childCoords: { x: 1, y: 0 },
                            generation: 0,
                            moveIndex: 0,
                            move: [1, 0],
                            dimensionKey: 'primary',
                            rawOutput: { value: 1 },
                        };
                        const preview = spaceDistortionFn(
                            { value: 1, isActive: true, contributors: 1, meta: [] },
                            sampleContext
                        );
                        if (preview !== undefined && preview !== null) {
                            const normalizedPreview = normalizeDimensionResult(preview);
                            if (!normalizedPreview) {
                                throw new Error('Space distortion must return a finite dimension descriptor.');
                            }
                        }
                    } catch (error) {
                        setEditorError('spaceDistortionLogic', true);
                        return false;
                    }
                }

                workerPositionSource = positionSourceRaw;
                workerSpaceDistortionSource = spaceDistortionSourceRaw;
            } else {
                workerPositionSource = '';
                workerSpaceDistortionSource = '';
            }

            const projectionTargetMode = projectionMode === 'isometric' ? 'isometric' : 'planar';
            setProjectionMode(projectionTargetMode);

            const nextConfig = {
                generations,
                reunification: controls.reunification.value,
                reunificationFn,
                reunificationSource,
                moves,
                propagationDimensions,
                propagationSources,
                dimensionDefaults,
                gradientMode,
                gradientCustom,
                colorFn,
                colorLogicSource,
                hdrFn,
                hdrLogicSource,
                effectiveValueFn,
                effectiveValueSource,
                backpropFn,
                backpropSource,
                backpropFillFn,
                backpropFillSource,
                backpropSteps,
                backpropStepModes: Array.isArray(config.backpropStepModes) ? config.backpropStepModes.slice() : null,
                binaryEnumerationSupported,
                projectionMode,
                xDistributionScale,
                positionSource: positionSourceRaw,
                positionFn,
                spaceDistortionSource: spaceDistortionSourceRaw,
                spaceDistortionFn,
            };
            nextConfig.workerPayload = {
                generations,
                moves,
                propagation: propagationDimensions.map(dimension => ({
                    key: dimension.key,
                    source: dimension.source,
                    defaultValue: dimension.defaultValue,
                    defaultActive: dimension.defaultActive,
                })),
                reunification: {
                    mode: reunificationMode,
                    source: reunificationMode === 'personalized' ? reunificationSource : '',
                },
                effectiveValueSource,
                backpropSource,
                backpropFillSource,
                backpropSteps,
                backpropStepModes: Array.isArray(config.backpropStepModes) ? config.backpropStepModes.slice() : null,
                binaryEnumerationSupported,
                dimensionDefaults,
                positionSource: workerPositionSource,
                spaceDistortionSource: workerSpaceDistortionSource,
            };
            config = nextConfig;
            app.config = config;
            return true;
        }

        function updateUIFromConfig() {
            controls.generations.value = config.generations;
            controls.reunification.value = config.reunification;
            setCodeValue('reunificationLogic', config.reunificationSource || defaultReunificationLogicSource);
            controls.backpropSteps.value = Number.isFinite(config.backpropSteps) ? config.backpropSteps : 0;
            controls.moves.value = JSON.stringify(config.moves, null, 2);
            const sources = config.propagationSources || {};
            setCodeValue('propagationPrimaryLogic', sources.primary ?? defaultPropagationSources.primary);
            setCodeValue('propagationSecondaryLogic', sources.secondary ?? defaultPropagationSources.secondary);
            setCodeValue('effectiveValueLogic', config.effectiveValueSource || defaultEffectiveValueSource);
            setCodeValue('backpropLogic', config.backpropSource || defaultBackpropLogicSource);
            setCodeValue('backpropFillLogic', config.backpropFillSource || defaultBackpropFillLogicSource);
            controls.gradientMode.value = config.gradientMode || 'symmetric';
            if (controls.gradientMode.value === 'custom' && config.gradientCustom) {
                controls.gradientMin.value = config.gradientCustom.min;
                controls.gradientMax.value = config.gradientCustom.max;
            }
            if (controls.xDistributionScale) {
                const scale = Number.isFinite(config.xDistributionScale) ? clampNumber(config.xDistributionScale, 0.25, 3) : 1;
                controls.xDistributionScale.value = scale;
                updateXDistributionLabel(scale);
            }
            setCodeValue('colorLogic', config.colorLogicSource || defaultColorLogicSource);
            setCodeValue('hdrLogic', config.hdrLogicSource || defaultHdrLogicSource);
            setCodeValue('positionLogic', config.positionSource || defaultPositionLogicSource);
            setCodeValue('spaceDistortionLogic', config.spaceDistortionSource || defaultSpaceDistortionSource);
            if (controls.projectionMode) {
                const availableModes = ['grid', 'isometric', 'custom'];
                const resolvedMode = config.projectionMode && availableModes.includes(config.projectionMode)
                    ? config.projectionMode
                    : (config.positionSource ? 'custom' : defaultProjectionMode || 'grid');
                controls.projectionMode.value = resolvedMode;
            }
            toggleCustomGradientInputs();
            toggleReunificationEditor();
            toggleSpatialEditors();
            binaryEnumerationSupported = Array.isArray(config.moves) && config.moves.length === 2;
            app.binaryEnumerationSupported = binaryEnumerationSupported;
            config.binaryEnumerationSupported = binaryEnumerationSupported;
        }

        function run() {
            if (!updateConfigFromUI()) return;

            const worker = app.workerBridge;
            const payload = config.workerPayload || null;
            if (worker && payload) {
                app.isComputing = true;
                app.pendingComputePayload = payload;
                drawGrid();
                worker.compute(payload).then((result) => {
                    if (app.pendingComputePayload !== payload) return;
                    applyGridPayload(result);
                    app.isComputing = false;
                    app.pendingComputePayload = null;
                    inspectorPanel.style.display = 'none';
                    updateInspectorBinarySection(null);
                    if (ENABLE_HOVER_ENUMERATION_POPUP) hideBinaryHoverPopup();
                    notifyBackpropApplied();
                    drawGrid();
                }).catch((error) => {
                    console.warn('Worker computation failed, falling back to main thread', error);
                    app.isComputing = false;
                    app.pendingComputePayload = null;
                    generateGridSync();
                    resetViewCaches();
                    const stats = computeGridStats(true);
                    app.cachedStats = stats;
                    inspectorPanel.style.display = 'none';
                    updateInspectorBinarySection(null);
                    if (ENABLE_HOVER_ENUMERATION_POPUP) hideBinaryHoverPopup();
                    notifyBackpropApplied();
                    drawGrid();
                });
                return;
            }

            generateGridSync();
            resetViewCaches();
            const stats = computeGridStats(true);
            app.cachedStats = stats;
            inspectorPanel.style.display = 'none';
            updateInspectorBinarySection(null);
            if (ENABLE_HOVER_ENUMERATION_POPUP) hideBinaryHoverPopup();
            notifyBackpropApplied();
            drawGrid();
        }

        function findNodeAt(mouseX, mouseY) {
            const rect = canvas.getBoundingClientRect();
            const safeScale = Math.max(view.scale, MIN_VIEW_SCALE);
            const gridX = (mouseX - rect.left - (canvas.width / 2 + view.offsetX)) / safeScale;
            const gridY = (mouseY - rect.top - (canvas.height / 2 + view.offsetY)) / safeScale;
            const aggregationMultiplier = view.scale < AGGREGATION_SCALE_THRESHOLD
                ? Math.min(3, Math.max(1.5, AGGREGATION_SCALE_THRESHOLD / Math.max(view.scale, 0.1)))
                : 1;
            const hitRadius = Math.max(getNodeRadius() * aggregationMultiplier, 0.3);
            for (const [key, node] of grid.entries()) {
                const { x: nodeX, y: nodeY } = getNodeRenderPosition(node, key);
                if (Math.hypot(gridX - nodeX, gridY - nodeY) < hitRadius) return key;
            }
            return null;
        }

        function updateInspectorPanel(nodeKey) {
            if (!nodeKey || !grid.has(nodeKey)) {
                inspectorPanel.style.display = 'none';
                updateInspectorBinarySection(null);
                return;
            }
            if (ENABLE_HOVER_ENUMERATION_POPUP) {
                hideBinaryHoverPopup();
            }
            const node = grid.get(nodeKey);
            if (inspectorFields.coords) inspectorFields.coords.textContent = `(${nodeKey})`;
            if (inspectorFields.value) inspectorFields.value.textContent = node.value.toFixed(4);
            if (inspectorFields.gen) inspectorFields.gen.textContent = node.gen;
            renderInspectorNodeLinks(inspectorFields.parents, Array.isArray(node.parents) ? node.parents : []);
            renderInspectorNodeLinks(inspectorFields.children, Array.isArray(node.children) ? node.children : []);
            updateInspectorBinarySection(nodeKey);
            inspectorPanel.style.display = 'block';
        }

        function renderInspectorNodeLinks(container, keys) {
            if (!container) return;
            container.innerHTML = '';
            const uniqueKeys = Array.from(new Set((keys || []).filter(Boolean)));
            if (!uniqueKeys.length) {
                container.textContent = 'None';
                return;
            }
            uniqueKeys.forEach(key => {
                const link = document.createElement('span');
                link.className = 'inspector-node-link';
                link.dataset.nodeKey = key;
                link.setAttribute('role', 'button');
                link.setAttribute('tabindex', '0');
                link.textContent = key;
                container.appendChild(link);
            });
        }

        function saveProject() {
            const name = controls.projectName.value.trim();
            if (!name) { alert('Please enter a project name.'); return; }
            if (!updateConfigFromUI()) { alert('Please resolve configuration errors before saving.'); return; }
            const projects = JSON.parse(localStorage.getItem('gridSimProjects') || '{}');
            projects[name] = {
                generations: config.generations,
                reunification: config.reunification,
                reunificationLogic: config.reunificationSource,
                moves: config.moves,
                propagationSources: config.propagationSources,
                effectiveValueLogic: config.effectiveValueSource,
                backpropLogic: config.backpropSource,
                backpropFillLogic: config.backpropFillSource,
                backpropSteps: config.backpropSteps,
                backpropStepModes: Array.isArray(config.backpropStepModes) ? config.backpropStepModes.slice() : null,
                gradientMode: config.gradientMode,
                gradientCustom: config.gradientCustom,
                colorLogic: config.colorLogicSource,
                hdrLogic: config.hdrLogicSource,
                positionLogic: config.positionSource,
                spaceDistortionLogic: config.spaceDistortionSource,
                projectionMode: config.projectionMode,
                xDistributionScale: config.xDistributionScale,
                version: 5,
            };
            localStorage.setItem('gridSimProjects', JSON.stringify(projects));
            updateProjectList();
        }

        function loadProject() {
            const name = controls.loadProjectSelect.value;
            if (!name) return;
            const projects = JSON.parse(localStorage.getItem('gridSimProjects') || '{}');
            if (projects[name]) {
                const proj = projects[name];
                if (controls.projectionMode) {
                    const availableModes = ['grid', 'isometric', 'custom'];
                    const loadedMode = proj.projectionMode && availableModes.includes(proj.projectionMode)
                        ? proj.projectionMode
                        : (proj.positionLogic ? 'custom' : 'grid');
                    controls.projectionMode.value = loadedMode;
                }
                controls.generations.value = proj.generations;
                controls.reunification.value = proj.reunification;
                setCodeValue('reunificationLogic', proj.reunificationLogic || defaultReunificationLogicSource);
                controls.moves.value = JSON.stringify(proj.moves, null, 2);
                const sources = proj.propagationSources || {};
                setCodeValue('propagationPrimaryLogic', sources.primary ?? proj.logic ?? defaultPropagationSources.primary);
                setCodeValue('propagationSecondaryLogic', sources.secondary ?? defaultPropagationSources.secondary);
                setCodeValue('effectiveValueLogic', proj.effectiveValueLogic || defaultEffectiveValueSource);
                setCodeValue('backpropLogic', proj.backpropLogic || defaultBackpropLogicSource);
                setCodeValue('backpropFillLogic', proj.backpropFillLogic || defaultBackpropFillLogicSource);
                controls.backpropSteps.value = Number.isFinite(proj.backpropSteps) ? proj.backpropSteps : 0;
                controls.gradientMode.value = proj.gradientMode || 'symmetric';
                if (controls.gradientMode.value === 'custom' && proj.gradientCustom) {
                    controls.gradientMin.value = proj.gradientCustom.min;
                    controls.gradientMax.value = proj.gradientCustom.max;
                }
                if (controls.xDistributionScale) {
                    const scale = Number.isFinite(proj.xDistributionScale) ? clampNumber(proj.xDistributionScale, 0.25, 100) : 1;
                    controls.xDistributionScale.value = scale;
                    updateXDistributionLabel(scale);
                }
                setCodeValue('colorLogic', proj.colorLogic || defaultColorLogicSource);
                setCodeValue('hdrLogic', proj.hdrLogic || defaultHdrLogicSource);
                setCodeValue('positionLogic', proj.positionLogic || defaultPositionLogicSource);
                setCodeValue('spaceDistortionLogic', proj.spaceDistortionLogic || defaultSpaceDistortionSource);
                controls.projectName.value = name;
                config.backpropStepModes = Array.isArray(proj.backpropStepModes) ? proj.backpropStepModes.slice() : null;
                toggleCustomGradientInputs();
                toggleReunificationEditor();
                toggleSpatialEditors();
                scheduleRunImmediate();
            }
        }

        function deleteProject() {
            const name = controls.loadProjectSelect.value;
            if (!name || !confirm(`Delete project "${name}"?`)) return;
            const projects = JSON.parse(localStorage.getItem('gridSimProjects') || '{}');
            delete projects[name];
            localStorage.setItem('gridSimProjects', JSON.stringify(projects));
            controls.projectName.value = "";
            updateProjectList();
        }

        function updateProjectList() {
            const projects = JSON.parse(localStorage.getItem('gridSimProjects') || '{}');
            const currentSelection = controls.loadProjectSelect.value;
            controls.loadProjectSelect.innerHTML = '<option value="">-- Load Project --</option>';
            for (const name in projects) {
                const option = document.createElement('option');
                option.value = name; option.textContent = name;
                controls.loadProjectSelect.appendChild(option);
            }
            controls.loadProjectSelect.value = currentSelection;
        }

        const presets = {
            pascal: {
                moves: `[[1, -1], [1, 1]]`,
                propagation: {
                    primary: `return parentValue;`,
                    secondary: defaultPropagationSources.secondary,
                },
                effective: `const primary = dimensions.primary?.value ?? 0;\nreturn primary;`,
                backprop: defaultBackpropLogicSource,
                backpropSteps: 0,
                gradientMode: 'symmetric',
                colorLogic: defaultColorLogicSource,
                hdrLogic: defaultHdrLogicSource,
            },
            divergent: {
                moves: `[[1, -1], [1, 1]]`,
                propagation: {
                    primary: `const delta = index === 0 ? 0.2 : -0.3;\nreturn parentValue + delta;`,
                    secondary: defaultPropagationSources.secondary,
                },
                effective: defaultEffectiveValueSource,
                backprop: defaultBackpropLogicSource,
                backpropSteps: 0,
                gradientMode: 'symmetric',
                colorLogic: defaultColorLogicSource,
                hdrLogic: defaultHdrLogicSource,
            },
            backwards: {
                moves: `[[1, -1], [1, 1], [-2, 0]]`,
                propagation: {
                    primary: `if (index === 2) return parentValue * 0.2;\nreturn parentValue * 0.5;`,
                    secondary: defaultPropagationSources.secondary,
                },
                effective: defaultEffectiveValueSource,
                backprop: defaultBackpropLogicSource,
                backpropSteps: 1,
                gradientMode: 'custom',
                gradientCustom: { min: -2, max: 2 },
                colorLogic: defaultColorLogicSource,
                hdrLogic: defaultHdrLogicSource,
            },
            decay: {
                moves: `[[1, -1], [1, 1]]`,
                propagation: {
                    primary: `return parentValue * 0.8;`,
                    secondary: defaultPropagationSources.secondary,
                },
                effective: defaultEffectiveValueSource,
                backprop: defaultBackpropLogicSource,
                backpropSteps: 0,
                gradientMode: 'positive',
                colorLogic: defaultColorLogicSource,
                hdrLogic: defaultHdrLogicSource,
            },
            sierpinski: {
                moves: `[[1, -1], [1, 1]]`,
                propagation: {
                    primary: `const parity = Math.abs(Math.round(parentValue)) % 2;\nreturn parity;`,
                    secondary: defaultPropagationSources.secondary,
                },
                effective: `return dimensions.primary?.value ?? 0;`,
                backprop: `const helper = context && typeof context.reverseFill === 'function' ? context.reverseFill : null;\nif (!helper) return null;\nconst outcome = helper(childState, parentState, context);\nif (!outcome || typeof outcome !== 'object') return null;\nreturn outcome;`,
                backpropFill: `const parseKey = (key) => {
    const parts = String(key || '').split(',');
    const x = Number(parts[0]);
    const y = Number(parts[1]);
    return {
        x: Number.isFinite(x) ? x : 0,
        y: Number.isFinite(y) ? y : 0,
    };
};

if (!childState || typeof childState !== 'object') return null;
const coords = parseKey(childState.key);
const row = Number.isFinite(childState.generation) ? childState.generation : coords.x;
if (!Number.isFinite(row) || row < 0) return null;
const colRaw = (row + coords.y) / 2;
const col = Number.isFinite(colRaw) ? Math.round(colRaw) : 0;
if (col < 0 || col > row) return null;

const leftMoves = row - col;
const rightMoves = col;
const conflict = leftMoves & rightMoves;
if (conflict === 0) return null;

const highestBit = 1 << Math.floor(Math.log2(conflict));
if (!Number.isFinite(highestBit) || highestBit <= 0) return null;
const apexLeft = leftMoves & ~(highestBit - 1);
const apexRight = rightMoves & ~(highestBit - 1);
const localLeft = leftMoves - apexLeft;
const localRight = rightMoves - apexRight;

const stepIndex = (context && Number.isFinite(context.step)) ? context.step : 0;
const maxLayer = Math.floor(Math.log2(highestBit));
if (stepIndex > maxLayer) return null;

const mask = highestBit - 1;
const orientationReverse = (localLeft & localRight) === 0;
const mirroredLeft = mask >= 0 ? (mask - localLeft) : 0;
const mirroredRight = mask >= 0 ? (mask - localRight) : 0;
const orientationForward = mask >= 0 && ((mirroredLeft & mirroredRight) === 0);

const stepModeRaw = (context && typeof context.mode === 'string') ? context.mode.toLowerCase() : null;
let requireReverse = false;
let requireForward = false;
if (stepModeRaw === 'reverse') {
    requireReverse = true;
} else if (stepModeRaw === 'forward') {
    requireForward = true;
} else if (stepModeRaw === 'both' || stepModeRaw === 'either') {
    requireReverse = false;
    requireForward = false;
} else {
    requireReverse = (stepIndex % 2) === 0;
    requireForward = !requireReverse;
}
if (requireReverse && !orientationReverse) return null;
if (requireForward && !orientationForward) return null;

const fillValue = Math.min(4, 2 + stepIndex);
const currentValue = Number.isFinite(childState.value) ? childState.value : 0;
if (fillValue <= currentValue + 1e-6) return null;

return {
    child: {
        valueOverride: fillValue,
    },
};`,
                backpropSteps: 0,
                backpropStepModes: ['reverse', 'forward', 'forward'],
                gradientMode: 'custom',
                gradientCustom: { min: 0, max: 4 },
                colorLogic: `if (value >= 3.5) {\n    return 'rgb(170, 140, 255)';\n}\nif (value >= 2.5) {\n    return 'rgb(236, 80, 192)';\n}\nconst parity = Math.abs(Math.round(value)) % 2;\nif (parity === 1) {\n    return 'rgb(64, 214, 204)';\n}\nreturn 'rgb(12, 14, 24)';`,
                hdrLogic: defaultHdrLogicSource,
                generations: 180,
                reunification: 'sum',
            },
            sierpinskiZeta: {
                moves: `[[1, -1], [1, 1]]`,
                propagation: {
                    primary: `const discrete = parentDimensions?.primary?.value;\nif (Number.isFinite(discrete)) {\n    return Math.abs(Math.round(discrete)) % 2;\n}\nreturn Math.abs(Math.round(parentValue)) % 2;`,
                    secondary: defaultPropagationSources.secondary,
                },
                effective: `const raw = dimensions.primary?.value ?? 0;\nconst parity = Math.abs(Math.round(raw)) % 2;\nconst generation = context.generation ?? 0;\nconst coords = (context.key || '0,0').split(',');\nconst x = Number(coords[0]) || 0;\nconst y = Number(coords[1]) || 0;\nconst radius = Math.sqrt(x * x + y * y);\nconst terms = Math.min(256, Math.max(2, generation + 2));\nlet harmonic = 0;\nfor (let n = 1; n <= terms; n++) {\n    harmonic += 1 / n;\n}\nconst angular = Math.cos((x - y) * 0.045 + generation * 0.08);\nconst distortion = Math.sin(radius * 0.085 + generation * 0.12);\nconst warp = 1 + distortion * 0.65 + angular * 0.35;\nconst zetaPole = harmonic * Math.max(0.2, warp);\nif (parity === 1) {\n    return zetaPole;\n}\nconst holeBoost = raw > 1 ? 0.65 : 0.35;\nreturn -zetaPole * holeBoost;`,
                backprop: `const discrete = childState.dimensions?.primary?.value ?? 0;\nconst parity = Math.abs(Math.round(discrete)) % 2;\nif (parity === 1) return null;\nconst generation = context.generation ?? childState.generation ?? 0;\nconst terms = Math.min(256, Math.max(2, generation + 2));\nlet harmonic = 0;\nfor (let n = 1; n <= terms; n++) {\n    harmonic += 1 / n;\n}\nconst target = -harmonic * (discrete > 1 ? 0.65 : 0.35);\nconst delta = (target - childState.value) * 0.3;\nif (!Number.isFinite(delta) || Math.abs(delta) < 1e-6) return null;\nreturn { child: { valueDelta: delta } };`,
                backpropSteps: 1,
                gradientMode: 'custom',
                gradientCustom: { min: -5, max: 5 },
                colorLogic: `const amplitude = Math.abs(value);\nconst span = Math.max(Math.abs(range.max), Math.abs(range.min), 1);\nconst normalized = Math.min(1, amplitude / span);\nconst hue = value >= 0 ? 190 - normalized * 60 : 320 + normalized * 25;\nconst saturation = 58 + normalized * 30;\nconst lightness = value >= 0 ? 24 + normalized * 42 : 46 - normalized * 20;\nreturn 'hsl(' + Math.round(hue) + ', ' + Math.round(saturation) + '%, ' + Math.round(lightness) + '%)';`,
                projectionMode: 'grid',
                positionLogic: `const snapshot = node || context?.node || null;\nconst generation = snapshot?.gen ?? context.generation ?? 0;\nconst coords = (key || '0,0').split(',');\nconst dx = Number(coords[0]) || 0;\nconst dy = Number(coords[1]) || 0;\nconst harmonic = snapshot?.dimensions?.primary?.value ?? 0;\nconst zetaValue = snapshot?.value ?? 0;\nconst radial = Math.log1p(Math.abs(dx) + Math.abs(dy));\nconst skew = (dx - dy) * 0.04;\nconst spiral = radial * 0.18;\nconst x = generation * 1.12 + skew + spiral * Math.cos(generation * 0.08);\nconst y = -zetaValue * 0.88 + harmonic * 0.12 + spiral * Math.sin(generation * 0.06);\nconst depth = (snapshot?.pathMeta?.depth ?? generation) > 0 ? zetaValue * 0.06 : 0;\nreturn { x, y, z: depth };`,
                spaceDistortionLogic: `if (!baseResult) return null;\nconst { parentSnapshot, childCoords, generation, dimensionKey } = context;\nconst parentValue = parentSnapshot?.value ?? 0;\nconst radius = Math.hypot(childCoords.x, childCoords.y);\nconst wave = Math.sin(radius * 0.045 + generation * 0.12);\nconst envelope = 1 + Math.log1p(radius) * 0.18;\nconst polarity = parentValue >= 0 ? 1.08 : 0.9;\nconst channelBias = dimensionKey === 'primary' ? 1.0 : 0.45;\nconst multiplier = (1 + wave * 0.3 * channelBias) * envelope * polarity;\nconst meta = Array.isArray(baseResult.meta) ? baseResult.meta.slice() : [];\nmeta.push({ distortion: multiplier, radius, wave });\nreturn { ...baseResult, value: baseResult.value * multiplier, meta };`,
                hdrLogic: defaultHdrLogicSource,
                generations: 192,
                reunification: 'sum',
            },
        };

        function loadPreset(preset) {
            if (Number.isFinite(preset.generations)) {
                controls.generations.value = preset.generations;
            }
            if (typeof preset.reunification === 'string') {
                controls.reunification.value = preset.reunification;
            }
            setCodeValue('reunificationLogic', preset.reunificationLogic || defaultReunificationLogicSource);
            controls.moves.value = preset.moves;
            if (preset.propagation) {
                setCodeValue('propagationPrimaryLogic', preset.propagation.primary ?? defaultPropagationSources.primary);
                setCodeValue('propagationSecondaryLogic', preset.propagation.secondary ?? defaultPropagationSources.secondary);
            }
            setCodeValue('effectiveValueLogic', preset.effective ?? defaultEffectiveValueSource);
            setCodeValue('backpropLogic', preset.backprop ?? defaultBackpropLogicSource);
            setCodeValue('backpropFillLogic', preset.backpropFill ?? defaultBackpropFillLogicSource);
            controls.backpropSteps.value = Number.isFinite(preset.backpropSteps) ? preset.backpropSteps : 0;
            controls.gradientMode.value = preset.gradientMode || 'symmetric';
            if (controls.gradientMode.value === 'custom' && preset.gradientCustom) {
                controls.gradientMin.value = preset.gradientCustom.min;
                controls.gradientMax.value = preset.gradientCustom.max;
            }
            if (controls.xDistributionScale) {
                const scale = Number.isFinite(preset.xDistributionScale) ? clampNumber(preset.xDistributionScale, 0.25, 100) : 1;
                controls.xDistributionScale.value = scale;
                updateXDistributionLabel(scale);
            }
            setCodeValue('colorLogic', preset.colorLogic || defaultColorLogicSource);
            setCodeValue('hdrLogic', preset.hdrLogic || defaultHdrLogicSource);
            const presetPositionLogic = typeof preset.positionLogic === 'string'
                ? preset.positionLogic
                : (preset.position && typeof preset.position.logic === 'string' ? preset.position.logic : null);
            const presetSpaceDistortionLogic = typeof preset.spaceDistortionLogic === 'string'
                ? preset.spaceDistortionLogic
                : (preset.spaceDistortion && typeof preset.spaceDistortion.logic === 'string' ? preset.spaceDistortion.logic : null);
            setCodeValue('positionLogic', presetPositionLogic ?? defaultPositionLogicSource);
            setCodeValue('spaceDistortionLogic', presetSpaceDistortionLogic ?? defaultSpaceDistortionSource);
            if (controls.projectionMode) {
                const availableModes = ['grid', 'isometric', 'custom'];
                let mode = preset.projectionMode || preset.positionMode;
                if (!mode) {
                    mode = presetPositionLogic ? 'custom' : 'grid';
                }
                if (!availableModes.includes(mode)) {
                    mode = 'grid';
                }
                controls.projectionMode.value = mode;
            }
            config.backpropStepModes = Array.isArray(preset.backpropStepModes) ? preset.backpropStepModes.slice() : null;
            toggleCustomGradientInputs();
            toggleReunificationEditor();
            toggleSpatialEditors();
            scheduleRunImmediate();
        }

        // --- Event Listeners ---
        ['generations', 'moves', 'gradientMin', 'gradientMax', 'xDistributionScale'].forEach(id => {
            const element = document.getElementById(id);
            if (element) element.addEventListener('input', scheduleRunImmediate);
        });
        if (controls.xDistributionScale) {
            controls.xDistributionScale.addEventListener('input', () => {
                updateXDistributionLabel(controls.xDistributionScale.value);
            });
        }
        if (controls.backpropSteps) {
            const handleBackpropStepsInput = (event) => {
                if (event && event.isTrusted) {
                    markBackpropPending('steps');
                }
                scheduleRunDebounced();
            };
            controls.backpropSteps.addEventListener('input', handleBackpropStepsInput);
        }

        if (controls.reunification) {
            controls.reunification.addEventListener('change', () => {
                toggleReunificationEditor();
                scheduleRunImmediate();
            });
        }

        controls.gradientMode.addEventListener('change', () => {
            toggleCustomGradientInputs();
            scheduleRunImmediate();
        });
        if (controls.projectionMode) {
            controls.projectionMode.addEventListener('change', () => {
                toggleSpatialEditors();
                scheduleRunImmediate();
            });
        }

        controls.saveProjectBtn.onclick = saveProject;
        controls.loadProjectSelect.onchange = loadProject;
        controls.deleteProjectBtn.onclick = deleteProject;
        controls.presetPascal.onclick = () => loadPreset(presets.pascal);
        controls.presetDivergent.onclick = () => loadPreset(presets.divergent);
        controls.presetBackwards.onclick = () => loadPreset(presets.backwards);
        controls.presetDecay.onclick = () => loadPreset(presets.decay);
        controls.presetSierpinski.onclick = () => loadPreset(presets.sierpinski);
        controls.presetSierpinskiZeta.onclick = () => loadPreset(presets.sierpinskiZeta);
        controls.inspectorCloseBtn.onclick = () => {
            inspectorPanel.style.display = 'none';
            selectedNodeKey = null;
            app.selectedNodeKey = selectedNodeKey;
            updateInspectorBinarySection(null);
            drawGrid();
        };
        inspectorPanel.addEventListener('click', (event) => {
            const target = event.target instanceof Element ? event.target.closest('.inspector-node-link') : null;
            if (!target) return;
            const nodeKey = target.dataset.nodeKey;
            if (!nodeKey || !grid.has(nodeKey)) return;
            selectedNodeKey = nodeKey;
            app.selectedNodeKey = selectedNodeKey;
            updateInspectorPanel(nodeKey);
            drawGrid();
        });
        inspectorPanel.addEventListener('keydown', (event) => {
            if (event.defaultPrevented) return;
            if (event.key !== 'Enter' && event.key !== ' ') return;
            const target = event.target;
            if (!target.classList || !target.classList.contains('inspector-node-link')) return;
            event.preventDefault();
            const nodeKey = target.dataset.nodeKey;
            if (!nodeKey || !grid.has(nodeKey)) return;
            selectedNodeKey = nodeKey;
            app.selectedNodeKey = selectedNodeKey;
            updateInspectorPanel(nodeKey);
            drawGrid();
        });
        if (ENABLE_HOVER_ENUMERATION_POPUP) {
            inspectorPanel.addEventListener('mouseover', handleInspectorHover);
            inspectorPanel.addEventListener('focusin', handleInspectorFocus);
            inspectorPanel.addEventListener('focusout', handleInspectorBlur);
            inspectorPanel.addEventListener('mouseleave', hideBinaryHoverPopup);
        }

        canvas.addEventListener('mousedown', e => { view.isDragging = true; view.lastX = e.clientX; view.lastY = e.clientY; });
        canvas.addEventListener('mouseup', () => { view.isDragging = false; canvas.style.cursor = 'grab'; });
        canvas.addEventListener('mouseleave', () => { view.isDragging = false; canvas.style.cursor = 'grab'; });
        canvas.addEventListener('mousemove', e => {
            if (!view.isDragging) return;
            canvas.style.cursor = 'grabbing';
            view.offsetX += e.clientX - view.lastX;
            view.offsetY += e.clientY - view.lastY;
            view.lastX = e.clientX;
            view.lastY = e.clientY;
            drawGrid();
        });
        if (ENABLE_HOVER_ENUMERATION_POPUP) {
            canvas.addEventListener('mousemove', handleCanvasBinaryHover);
            canvas.addEventListener('mouseleave', hideBinaryHoverPopup);
            canvas.addEventListener('mousedown', hideBinaryHoverPopup);
        }

        let generateGridScrollTimeout = null;
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const canvasWidth = canvas.width || canvas.offsetWidth || rect.width;
            const canvasHeight = canvas.height || canvas.offsetHeight || rect.height;
            const pointerX = e.clientX - rect.left;
            const pointerY = e.clientY - rect.top;

            const currentScale = Number.isFinite(view.scale) ? view.scale : MIN_VIEW_SCALE;
            const scaleAmount = e.deltaY < 0 ? 1.05 : 1 / 1.05;
            const nextScale = clampNumber(currentScale * scaleAmount, MIN_VIEW_SCALE, MAX_VIEW_SCALE);

            const worldXBefore = (pointerX - (canvasWidth / 2 + view.offsetX)) / currentScale;
            const worldYBefore = (pointerY - (canvasHeight / 2 + view.offsetY)) / currentScale;

            view.scale = nextScale;
            view.offsetX = pointerX - canvasWidth / 2 - worldXBefore * nextScale;
            view.offsetY = pointerY - canvasHeight / 2 - worldYBefore * nextScale;

            drawGrid();
        });
        canvas.addEventListener('click', e => {
            if (Math.abs(e.clientX - view.lastX) < 3 && Math.abs(e.clientY - view.lastY) < 3) {
                selectedNodeKey = findNodeAt(e.clientX, e.clientY);
                app.selectedNodeKey = selectedNodeKey;
                updateInspectorPanel(selectedNodeKey);
                drawGrid();
            }
        });

        app.run = run;
        app.scheduleRunImmediate = scheduleRunImmediate;
        app.scheduleRunDebounced = scheduleRunDebounced;
        app.updateConfigFromUI = updateConfigFromUI;
        app.generateGrid = generateGridSync;
        app.drawGrid = drawGrid;
        app.applyGridPayload = applyGridPayload;
        app.resetViewCaches = resetViewCaches;
        app.setPositionLogic = setPositionLogic;
        app.setProjectionMode = setProjectionMode;
        app.getCodeValue = getCodeValue;
        app.setCodeValue = setCodeValue;
        app.setEditorError = setEditorError;
        app.toggleCustomGradientInputs = toggleCustomGradientInputs;
        app.toggleReunificationEditor = toggleReunificationEditor;
        app.toggleSpatialEditors = toggleSpatialEditors;
        app.refreshActiveEditors = refreshActiveEditors;
        app.ensureEditorExpanded = ensureEditorExpanded;
        app.setActiveEditor = setActiveEditor;

        // --- Initial Load ---
        updateProjectList();
        toggleCustomGradientInputs();
        toggleReunificationEditor();
        toggleSpatialEditors();
        run();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    window.gridSimulatorApp = new GridSimulatorApp(document);
});
</script>

</body>
</html>
